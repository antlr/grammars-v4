program
 classDefine
  class
  VarList
  inherits
  IO
  {
  feature
   isNil
   (
   )
   :
   Bool
   {
   expression
    true
   }
  ;
  feature
   head
   (
   )
   :
   Variable
   {
   expression
    {
    expression
     abort
     (
     )
    ;
    expression
     new
     Variable
    ;
    }
   }
  ;
  feature
   tail
   (
   )
   :
   VarList
   {
   expression
    {
    expression
     abort
     (
     )
    ;
    expression
     new
     VarList
    ;
    }
   }
  ;
  feature
   add
   (
   formal
    x
    :
    Variable
   )
   :
   VarList
   {
   expression
    expression
     (
     expression
      new
      VarListNE
     )
    .
    init
    (
    expression
     x
    ,
    expression
     self
    )
   }
  ;
  feature
   print
   (
   )
   :
   SELF_TYPE
   {
   expression
    out_string
    (
    expression
     "\n"
    )
   }
  ;
  }
 ;
 classDefine
  class
  VarListNE
  inherits
  VarList
  {
  feature
   x
   :
   Variable
  ;
  feature
   rest
   :
   VarList
  ;
  feature
   isNil
   (
   )
   :
   Bool
   {
   expression
    false
   }
  ;
  feature
   head
   (
   )
   :
   Variable
   {
   expression
    x
   }
  ;
  feature
   tail
   (
   )
   :
   VarList
   {
   expression
    rest
   }
  ;
  feature
   init
   (
   formal
    y
    :
    Variable
   ,
   formal
    r
    :
    VarList
   )
   :
   VarListNE
   {
   expression
    {
    expression
     x
     <-
     expression
      y
    ;
    expression
     rest
     <-
     expression
      r
    ;
    expression
     self
    ;
    }
   }
  ;
  feature
   print
   (
   )
   :
   SELF_TYPE
   {
   expression
    {
    expression
     expression
      x
     .
     print_self
     (
     )
    ;
    expression
     out_string
     (
     expression
      " "
     )
    ;
    expression
     expression
      rest
     .
     print
     (
     )
    ;
    expression
     self
    ;
    }
   }
  ;
  }
 ;
 classDefine
  class
  LambdaList
  {
  feature
   isNil
   (
   )
   :
   Bool
   {
   expression
    true
   }
  ;
  feature
   headE
   (
   )
   :
   VarList
   {
   expression
    {
    expression
     abort
     (
     )
    ;
    expression
     new
     VarList
    ;
    }
   }
  ;
  feature
   headC
   (
   )
   :
   Lambda
   {
   expression
    {
    expression
     abort
     (
     )
    ;
    expression
     new
     Lambda
    ;
    }
   }
  ;
  feature
   headN
   (
   )
   :
   Int
   {
   expression
    {
    expression
     abort
     (
     )
    ;
    expression
     0
    ;
    }
   }
  ;
  feature
   tail
   (
   )
   :
   LambdaList
   {
   expression
    {
    expression
     abort
     (
     )
    ;
    expression
     new
     LambdaList
    ;
    }
   }
  ;
  feature
   add
   (
   formal
    e
    :
    VarList
   ,
   formal
    x
    :
    Lambda
   ,
   formal
    n
    :
    Int
   )
   :
   LambdaList
   {
   expression
    expression
     (
     expression
      new
      LambdaListNE
     )
    .
    init
    (
    expression
     e
    ,
    expression
     x
    ,
    expression
     n
    ,
    expression
     self
    )
   }
  ;
  }
 ;
 classDefine
  class
  LambdaListNE
  inherits
  LambdaList
  {
  feature
   lam
   :
   Lambda
  ;
  feature
   num
   :
   Int
  ;
  feature
   env
   :
   VarList
  ;
  feature
   rest
   :
   LambdaList
  ;
  feature
   isNil
   (
   )
   :
   Bool
   {
   expression
    false
   }
  ;
  feature
   headE
   (
   )
   :
   VarList
   {
   expression
    env
   }
  ;
  feature
   headC
   (
   )
   :
   Lambda
   {
   expression
    lam
   }
  ;
  feature
   headN
   (
   )
   :
   Int
   {
   expression
    num
   }
  ;
  feature
   tail
   (
   )
   :
   LambdaList
   {
   expression
    rest
   }
  ;
  feature
   init
   (
   formal
    e
    :
    VarList
   ,
   formal
    l
    :
    Lambda
   ,
   formal
    n
    :
    Int
   ,
   formal
    r
    :
    LambdaList
   )
   :
   LambdaListNE
   {
   expression
    {
    expression
     env
     <-
     expression
      e
    ;
    expression
     lam
     <-
     expression
      l
    ;
    expression
     num
     <-
     expression
      n
    ;
    expression
     rest
     <-
     expression
      r
    ;
    expression
     self
    ;
    }
   }
  ;
  }
 ;
 classDefine
  class
  LambdaListRef
  {
  feature
   nextNum
   :
   Int
   <-
   expression
    0
  ;
  feature
   l
   :
   LambdaList
  ;
  feature
   isNil
   (
   )
   :
   Bool
   {
   expression
    expression
     l
    .
    isNil
    (
    )
   }
  ;
  feature
   headE
   (
   )
   :
   VarList
   {
   expression
    expression
     l
    .
    headE
    (
    )
   }
  ;
  feature
   headC
   (
   )
   :
   Lambda
   {
   expression
    expression
     l
    .
    headC
    (
    )
   }
  ;
  feature
   headN
   (
   )
   :
   Int
   {
   expression
    expression
     l
    .
    headN
    (
    )
   }
  ;
  feature
   reset
   (
   )
   :
   SELF_TYPE
   {
   expression
    {
    expression
     nextNum
     <-
     expression
      0
    ;
    expression
     l
     <-
     expression
      new
      LambdaList
    ;
    expression
     self
    ;
    }
   }
  ;
  feature
   add
   (
   formal
    env
    :
    VarList
   ,
   formal
    c
    :
    Lambda
   )
   :
   Int
   {
   expression
    {
    expression
     l
     <-
     expression
      expression
       l
      .
      add
      (
      expression
       env
      ,
      expression
       c
      ,
      expression
       nextNum
      )
    ;
    expression
     nextNum
     <-
     expression
      expression
       nextNum
      +
      expression
       1
    ;
    expression
     expression
      nextNum
     -
     expression
      1
    ;
    }
   }
  ;
  feature
   removeHead
   (
   )
   :
   SELF_TYPE
   {
   expression
    {
    expression
     l
     <-
     expression
      expression
       l
      .
      tail
      (
      )
    ;
    expression
     self
    ;
    }
   }
  ;
  }
 ;
 classDefine
  class
  Expr
  inherits
  IO
  {
  feature
   print_self
   (
   )
   :
   SELF_TYPE
   {
   expression
    {
    expression
     out_string
     (
     expression
      "\nError: Expr is pure virtual; can't print self\n"
     )
    ;
    expression
     abort
     (
     )
    ;
    expression
     self
    ;
    }
   }
  ;
  feature
   beta
   (
   )
   :
   Expr
   {
   expression
    {
    expression
     out_string
     (
     expression
      "\nError: Expr is pure virtual; can't beta-reduce\n"
     )
    ;
    expression
     abort
     (
     )
    ;
    expression
     self
    ;
    }
   }
  ;
  feature
   substitute
   (
   formal
    x
    :
    Variable
   ,
   formal
    e
    :
    Expr
   )
   :
   Expr
   {
   expression
    {
    expression
     out_string
     (
     expression
      "\nError: Expr is pure virtual; can't substitute\n"
     )
    ;
    expression
     abort
     (
     )
    ;
    expression
     self
    ;
    }
   }
  ;
  feature
   gen_code
   (
   formal
    env
    :
    VarList
   ,
   formal
    closures
    :
    LambdaListRef
   )
   :
   SELF_TYPE
   {
   expression
    {
    expression
     out_string
     (
     expression
      "\nError: Expr is pure virtual; can't gen_code\n"
     )
    ;
    expression
     abort
     (
     )
    ;
    expression
     self
    ;
    }
   }
  ;
  }
 ;
 classDefine
  class
  Variable
  inherits
  Expr
  {
  feature
   name
   :
   String
  ;
  feature
   init
   (
   formal
    n
    :
    String
   )
   :
   Variable
   {
   expression
    {
    expression
     name
     <-
     expression
      n
    ;
    expression
     self
    ;
    }
   }
  ;
  feature
   print_self
   (
   )
   :
   SELF_TYPE
   {
   expression
    out_string
    (
    expression
     name
    )
   }
  ;
  feature
   beta
   (
   )
   :
   Expr
   {
   expression
    self
   }
  ;
  feature
   substitute
   (
   formal
    x
    :
    Variable
   ,
   formal
    e
    :
    Expr
   )
   :
   Expr
   {
   expression
    if
    expression
     expression
      x
     =
     expression
      self
    then
    expression
     e
    else
    expression
     self
    fi
   }
  ;
  feature
   gen_code
   (
   formal
    env
    :
    VarList
   ,
   formal
    closures
    :
    LambdaListRef
   )
   :
   SELF_TYPE
   {
   expression
    let
    cur_env
    :
    VarList
    <-
    expression
     env
    in
    expression
     {
     expression
      while
      expression
       (
       expression
        if
        expression
         expression
          cur_env
         .
         isNil
         (
         )
        then
        expression
         false
        else
        expression
         not
         expression
          (
          expression
           expression
            expression
             cur_env
            .
            head
            (
            )
           =
           expression
            self
          )
        fi
       )
      loop
      expression
       {
       expression
        out_string
        (
        expression
         "get_parent()."
        )
       ;
       expression
        cur_env
        <-
        expression
         expression
          cur_env
         .
         tail
         (
         )
       ;
       }
      pool
     ;
     expression
      if
      expression
       expression
        cur_env
       .
       isNil
       (
       )
      then
      expression
       {
       expression
        out_string
        (
        expression
         "Error:  free occurrence of "
        )
       ;
       expression
        print_self
        (
        )
       ;
       expression
        out_string
        (
        expression
         "\n"
        )
       ;
       expression
        abort
        (
        )
       ;
       expression
        self
       ;
       }
      else
      expression
       out_string
       (
       expression
        "get_x()"
       )
      fi
     ;
     }
   }
  ;
  }
 ;
 classDefine
  class
  Lambda
  inherits
  Expr
  {
  feature
   arg
   :
   Variable
  ;
  feature
   body
   :
   Expr
  ;
  feature
   init
   (
   formal
    a
    :
    Variable
   ,
   formal
    b
    :
    Expr
   )
   :
   Lambda
   {
   expression
    {
    expression
     arg
     <-
     expression
      a
    ;
    expression
     body
     <-
     expression
      b
    ;
    expression
     self
    ;
    }
   }
  ;
  feature
   print_self
   (
   )
   :
   SELF_TYPE
   {
   expression
    {
    expression
     out_string
     (
     expression
      "\\"
     )
    ;
    expression
     expression
      arg
     .
     print_self
     (
     )
    ;
    expression
     out_string
     (
     expression
      "."
     )
    ;
    expression
     expression
      body
     .
     print_self
     (
     )
    ;
    expression
     self
    ;
    }
   }
  ;
  feature
   beta
   (
   )
   :
   Expr
   {
   expression
    self
   }
  ;
  feature
   apply
   (
   formal
    actual
    :
    Expr
   )
   :
   Expr
   {
   expression
    expression
     body
    .
    substitute
    (
    expression
     arg
    ,
    expression
     actual
    )
   }
  ;
  feature
   substitute
   (
   formal
    x
    :
    Variable
   ,
   formal
    e
    :
    Expr
   )
   :
   Expr
   {
   expression
    if
    expression
     expression
      x
     =
     expression
      arg
    then
    expression
     self
    else
    expression
     let
     new_body
     :
     Expr
     <-
     expression
      expression
       body
      .
      substitute
      (
      expression
       x
      ,
      expression
       e
      )
     ,
     new_lam
     :
     Lambda
     <-
     expression
      new
      Lambda
     in
     expression
      expression
       new_lam
      .
      init
      (
      expression
       arg
      ,
      expression
       new_body
      )
    fi
   }
  ;
  feature
   gen_code
   (
   formal
    env
    :
    VarList
   ,
   formal
    closures
    :
    LambdaListRef
   )
   :
   SELF_TYPE
   {
   expression
    {
    expression
     out_string
     (
     expression
      "((new Closure"
     )
    ;
    expression
     out_int
     (
     expression
      expression
       closures
      .
      add
      (
      expression
       env
      ,
      expression
       self
      )
     )
    ;
    expression
     out_string
     (
     expression
      ").init("
     )
    ;
    expression
     if
     expression
      expression
       env
      .
      isNil
      (
      )
     then
     expression
      out_string
      (
      expression
       "new Closure))"
      )
     else
     expression
      out_string
      (
      expression
       "self))"
      )
     fi
    ;
    expression
     self
    ;
    }
   }
  ;
  feature
   gen_closure_code
   (
   formal
    n
    :
    Int
   ,
   formal
    env
    :
    VarList
   ,
   formal
    closures
    :
    LambdaListRef
   )
   :
   SELF_TYPE
   {
   expression
    {
    expression
     out_string
     (
     expression
      "class Closure"
     )
    ;
    expression
     out_int
     (
     expression
      n
     )
    ;
    expression
     out_string
     (
     expression
      " inherits Closure {\n"
     )
    ;
    expression
     out_string
     (
     expression
      "  apply(y : EvalObject) : EvalObject {\n"
     )
    ;
    expression
     out_string
     (
     expression
      "    { out_string(\"Applying closure "
     )
    ;
    expression
     out_int
     (
     expression
      n
     )
    ;
    expression
     out_string
     (
     expression
      "\\n\");\n"
     )
    ;
    expression
     out_string
     (
     expression
      "      x <- y;\n"
     )
    ;
    expression
     expression
      body
     .
     gen_code
     (
     expression
      expression
       env
      .
      add
      (
      expression
       arg
      )
     ,
     expression
      closures
     )
    ;
    expression
     out_string
     (
     expression
      ";}};\n"
     )
    ;
    expression
     out_string
     (
     expression
      "};\n"
     )
    ;
    }
   }
  ;
  }
 ;
 classDefine
  class
  App
  inherits
  Expr
  {
  feature
   fun
   :
   Expr
  ;
  feature
   arg
   :
   Expr
  ;
  feature
   init
   (
   formal
    f
    :
    Expr
   ,
   formal
    a
    :
    Expr
   )
   :
   App
   {
   expression
    {
    expression
     fun
     <-
     expression
      f
    ;
    expression
     arg
     <-
     expression
      a
    ;
    expression
     self
    ;
    }
   }
  ;
  feature
   print_self
   (
   )
   :
   SELF_TYPE
   {
   expression
    {
    expression
     out_string
     (
     expression
      "(("
     )
    ;
    expression
     expression
      fun
     .
     print_self
     (
     )
    ;
    expression
     out_string
     (
     expression
      ")@("
     )
    ;
    expression
     expression
      arg
     .
     print_self
     (
     )
    ;
    expression
     out_string
     (
     expression
      "))"
     )
    ;
    expression
     self
    ;
    }
   }
  ;
  feature
   beta
   (
   )
   :
   Expr
   {
   expression
    case
    expression
     fun
    of
    l
    :
    Lambda
    =>
    expression
     expression
      l
     .
     apply
     (
     expression
      arg
     )
    ;
    e
    :
    Expr
    =>
    expression
     let
     new_fun
     :
     Expr
     <-
     expression
      expression
       fun
      .
      beta
      (
      )
     ,
     new_app
     :
     App
     <-
     expression
      new
      App
     in
     expression
      expression
       new_app
      .
      init
      (
      expression
       new_fun
      ,
      expression
       arg
      )
    ;
    esac
   }
  ;
  feature
   substitute
   (
   formal
    x
    :
    Variable
   ,
   formal
    e
    :
    Expr
   )
   :
   Expr
   {
   expression
    let
    new_fun
    :
    Expr
    <-
    expression
     expression
      fun
     .
     substitute
     (
     expression
      x
     ,
     expression
      e
     )
    ,
    new_arg
    :
    Expr
    <-
    expression
     expression
      arg
     .
     substitute
     (
     expression
      x
     ,
     expression
      e
     )
    ,
    new_app
    :
    App
    <-
    expression
     new
     App
    in
    expression
     expression
      new_app
     .
     init
     (
     expression
      new_fun
     ,
     expression
      new_arg
     )
   }
  ;
  feature
   gen_code
   (
   formal
    env
    :
    VarList
   ,
   formal
    closures
    :
    LambdaListRef
   )
   :
   SELF_TYPE
   {
   expression
    {
    expression
     out_string
     (
     expression
      "(let x : EvalObject <- "
     )
    ;
    expression
     expression
      fun
     .
     gen_code
     (
     expression
      env
     ,
     expression
      closures
     )
    ;
    expression
     out_string
     (
     expression
      ",\n"
     )
    ;
    expression
     out_string
     (
     expression
      "     y : EvalObject <- "
     )
    ;
    expression
     expression
      arg
     .
     gen_code
     (
     expression
      env
     ,
     expression
      closures
     )
    ;
    expression
     out_string
     (
     expression
      " in\n"
     )
    ;
    expression
     out_string
     (
     expression
      "  case x of\n"
     )
    ;
    expression
     out_string
     (
     expression
      "    c : Closure => c.apply(y);\n"
     )
    ;
    expression
     out_string
     (
     expression
      "    o : Object => { abort(); new EvalObject; };\n"
     )
    ;
    expression
     out_string
     (
     expression
      "  esac)"
     )
    ;
    }
   }
  ;
  }
 ;
 classDefine
  class
  Term
  inherits
  IO
  {
  feature
   var
   (
   formal
    x
    :
    String
   )
   :
   Variable
   {
   expression
    let
    v
    :
    Variable
    <-
    expression
     new
     Variable
    in
    expression
     expression
      v
     .
     init
     (
     expression
      x
     )
   }
  ;
  feature
   lam
   (
   formal
    x
    :
    Variable
   ,
   formal
    e
    :
    Expr
   )
   :
   Lambda
   {
   expression
    let
    l
    :
    Lambda
    <-
    expression
     new
     Lambda
    in
    expression
     expression
      l
     .
     init
     (
     expression
      x
     ,
     expression
      e
     )
   }
  ;
  feature
   app
   (
   formal
    e1
    :
    Expr
   ,
   formal
    e2
    :
    Expr
   )
   :
   App
   {
   expression
    let
    a
    :
    App
    <-
    expression
     new
     App
    in
    expression
     expression
      a
     .
     init
     (
     expression
      e1
     ,
     expression
      e2
     )
   }
  ;
  feature
   i
   (
   )
   :
   Expr
   {
   expression
    let
    x
    :
    Variable
    <-
    expression
     var
     (
     expression
      "x"
     )
    in
    expression
     lam
     (
     expression
      x
     ,
     expression
      x
     )
   }
  ;
  feature
   k
   (
   )
   :
   Expr
   {
   expression
    let
    x
    :
    Variable
    <-
    expression
     var
     (
     expression
      "x"
     )
    ,
    y
    :
    Variable
    <-
    expression
     var
     (
     expression
      "y"
     )
    in
    expression
     lam
     (
     expression
      x
     ,
     expression
      lam
      (
      expression
       y
      ,
      expression
       x
      )
     )
   }
  ;
  feature
   s
   (
   )
   :
   Expr
   {
   expression
    let
    x
    :
    Variable
    <-
    expression
     var
     (
     expression
      "x"
     )
    ,
    y
    :
    Variable
    <-
    expression
     var
     (
     expression
      "y"
     )
    ,
    z
    :
    Variable
    <-
    expression
     var
     (
     expression
      "z"
     )
    in
    expression
     lam
     (
     expression
      x
     ,
     expression
      lam
      (
      expression
       y
      ,
      expression
       lam
       (
       expression
        z
       ,
       expression
        app
        (
        expression
         app
         (
         expression
          x
         ,
         expression
          z
         )
        ,
        expression
         app
         (
         expression
          y
         ,
         expression
          z
         )
        )
       )
      )
     )
   }
  ;
  }
 ;
 classDefine
  class
  Main
  inherits
  Term
  {
  feature
   beta_reduce
   (
   formal
    e
    :
    Expr
   )
   :
   Expr
   {
   expression
    {
    expression
     out_string
     (
     expression
      "beta-reduce: "
     )
    ;
    expression
     expression
      e
     .
     print_self
     (
     )
    ;
    expression
     let
     done
     :
     Bool
     <-
     expression
      false
     ,
     new_expr
     :
     Expr
     in
     expression
      {
      expression
       while
       expression
        (
        expression
         not
         expression
          done
        )
       loop
       expression
        {
        expression
         new_expr
         <-
         expression
          expression
           e
          .
          beta
          (
          )
        ;
        expression
         if
         expression
          (
          expression
           expression
            new_expr
           =
           expression
            e
          )
         then
         expression
          done
          <-
          expression
           true
         else
         expression
          {
          expression
           e
           <-
           expression
            new_expr
          ;
          expression
           out_string
           (
           expression
            " =>\n"
           )
          ;
          expression
           expression
            e
           .
           print_self
           (
           )
          ;
          }
         fi
        ;
        }
       pool
      ;
      expression
       out_string
       (
       expression
        "\n"
       )
      ;
      expression
       e
      ;
      }
    ;
    }
   }
  ;
  feature
   eval_class
   (
   )
   :
   SELF_TYPE
   {
   expression
    {
    expression
     out_string
     (
     expression
      "class EvalObject inherits IO {\n"
     )
    ;
    expression
     out_string
     (
     expression
      "  eval() : EvalObject { { abort(); self; } };\n"
     )
    ;
    expression
     out_string
     (
     expression
      "};\n"
     )
    ;
    }
   }
  ;
  feature
   closure_class
   (
   )
   :
   SELF_TYPE
   {
   expression
    {
    expression
     out_string
     (
     expression
      "class Closure inherits EvalObject {\n"
     )
    ;
    expression
     out_string
     (
     expression
      "  parent : Closure;\n"
     )
    ;
    expression
     out_string
     (
     expression
      "  x : EvalObject;\n"
     )
    ;
    expression
     out_string
     (
     expression
      "  get_parent() : Closure { parent };\n"
     )
    ;
    expression
     out_string
     (
     expression
      "  get_x() : EvalObject { x };\n"
     )
    ;
    expression
     out_string
     (
     expression
      "  init(p : Closure) : Closure {{ parent <- p; self; }};\n"
     )
    ;
    expression
     out_string
     (
     expression
      "  apply(y : EvalObject) : EvalObject { { abort(); self; } };\n"
     )
    ;
    expression
     out_string
     (
     expression
      "};\n"
     )
    ;
    }
   }
  ;
  feature
   gen_code
   (
   formal
    e
    :
    Expr
   )
   :
   SELF_TYPE
   {
   expression
    let
    cl
    :
    LambdaListRef
    <-
    expression
     expression
      (
      expression
       new
       LambdaListRef
      )
     .
     reset
     (
     )
    in
    expression
     {
     expression
      out_string
      (
      expression
       "Generating code for "
      )
     ;
     expression
      expression
       e
      .
      print_self
      (
      )
     ;
     expression
      out_string
      (
      expression
       "\n------------------cut here------------------\n"
      )
     ;
     expression
      out_string
      (
      expression
       "(*Generated by lam.cl (Jeff Foster, March 2000)*)\n"
      )
     ;
     expression
      eval_class
      (
      )
     ;
     expression
      closure_class
      (
      )
     ;
     expression
      out_string
      (
      expression
       "class Main {\n"
      )
     ;
     expression
      out_string
      (
      expression
       "  main() : EvalObject {\n"
      )
     ;
     expression
      expression
       e
      .
      gen_code
      (
      expression
       new
       VarList
      ,
      expression
       cl
      )
     ;
     expression
      out_string
      (
      expression
       "\n};\n};\n"
      )
     ;
     expression
      while
      expression
       (
       expression
        not
        expression
         (
         expression
          expression
           cl
          .
          isNil
          (
          )
         )
       )
      loop
      expression
       let
       e
       :
       VarList
       <-
       expression
        expression
         cl
        .
        headE
        (
        )
       ,
       c
       :
       Lambda
       <-
       expression
        expression
         cl
        .
        headC
        (
        )
       ,
       n
       :
       Int
       <-
       expression
        expression
         cl
        .
        headN
        (
        )
       in
       expression
        {
        expression
         expression
          cl
         .
         removeHead
         (
         )
        ;
        expression
         expression
          c
         .
         gen_closure_code
         (
         expression
          n
         ,
         expression
          e
         ,
         expression
          cl
         )
        ;
        }
      pool
     ;
     expression
      out_string
      (
      expression
       "\n------------------cut here------------------\n"
      )
     ;
     }
   }
  ;
  feature
   main
   (
   )
   :
   Int
   {
   expression
    {
    expression
     expression
      i
      (
      )
     .
     print_self
     (
     )
    ;
    expression
     out_string
     (
     expression
      "\n"
     )
    ;
    expression
     expression
      k
      (
      )
     .
     print_self
     (
     )
    ;
    expression
     out_string
     (
     expression
      "\n"
     )
    ;
    expression
     expression
      s
      (
      )
     .
     print_self
     (
     )
    ;
    expression
     out_string
     (
     expression
      "\n"
     )
    ;
    expression
     beta_reduce
     (
     expression
      app
      (
      expression
       app
       (
       expression
        app
        (
        expression
         s
         (
         )
        ,
        expression
         k
         (
         )
        )
       ,
       expression
        i
        (
        )
       )
      ,
      expression
       i
       (
       )
      )
     )
    ;
    expression
     beta_reduce
     (
     expression
      app
      (
      expression
       app
       (
       expression
        k
        (
        )
       ,
       expression
        i
        (
        )
       )
      ,
      expression
       i
       (
       )
      )
     )
    ;
    expression
     gen_code
     (
     expression
      app
      (
      expression
       i
       (
       )
      ,
      expression
       i
       (
       )
      )
     )
    ;
    expression
     gen_code
     (
     expression
      app
      (
      expression
       app
       (
       expression
        app
        (
        expression
         s
         (
         )
        ,
        expression
         k
         (
         )
        )
       ,
       expression
        i
        (
        )
       )
      ,
      expression
       i
       (
       )
      )
     )
    ;
    expression
     gen_code
     (
     expression
      app
      (
      expression
       app
       (
       expression
        app
        (
        expression
         app
         (
         expression
          app
          (
          expression
           app
           (
           expression
            app
            (
            expression
             app
             (
             expression
              i
              (
              )
             ,
             expression
              k
              (
              )
             )
            ,
            expression
             s
             (
             )
            )
           ,
           expression
            s
            (
            )
           )
          ,
          expression
           k
           (
           )
          )
         ,
         expression
          s
          (
          )
         )
        ,
        expression
         i
         (
         )
        )
       ,
       expression
        k
        (
        )
       )
      ,
      expression
       i
       (
       )
      )
     )
    ;
    expression
     gen_code
     (
     expression
      app
      (
      expression
       app
       (
       expression
        i
        (
        )
       ,
       expression
        app
        (
        expression
         k
         (
         )
        ,
        expression
         s
         (
         )
        )
       )
      ,
      expression
       app
       (
       expression
        k
        (
        )
       ,
       expression
        app
        (
        expression
         s
         (
         )
        ,
        expression
         s
         (
         )
        )
       )
      )
     )
    ;
    expression
     0
    ;
    }
   }
  ;
  }
 ;
 <EOF>
