start_
 theory_decl
  (
  theory
  symbol
   simpleSymbol
    ArraysEx
  theory_attribute
   :sorts
   (
   sort_symbol_decl
    (
    identifier
     symbol
      simpleSymbol
       Array
    numeral
     2
    )
   )
  theory_attribute
   :funs
   (
   par_fun_symbol_decl
    (
    par
    (
    symbol
     simpleSymbol
      X
    symbol
     simpleSymbol
      Y
    )
    (
    identifier
     symbol
      simpleSymbol
       select
    sort
     (
     identifier
      symbol
       simpleSymbol
        Array
     sort
      identifier
       symbol
        simpleSymbol
         X
     sort
      identifier
       symbol
        simpleSymbol
         Y
     )
    sort
     identifier
      symbol
       simpleSymbol
        X
    sort
     identifier
      symbol
       simpleSymbol
        Y
    )
    )
   par_fun_symbol_decl
    (
    par
    (
    symbol
     simpleSymbol
      X
    symbol
     simpleSymbol
      Y
    )
    (
    identifier
     symbol
      simpleSymbol
       store
    sort
     (
     identifier
      symbol
       simpleSymbol
        Array
     sort
      identifier
       symbol
        simpleSymbol
         X
     sort
      identifier
       symbol
        simpleSymbol
         Y
     )
    sort
     identifier
      symbol
       simpleSymbol
        X
    sort
     identifier
      symbol
       simpleSymbol
        Y
    sort
     (
     identifier
      symbol
       simpleSymbol
        Array
     sort
      identifier
       symbol
        simpleSymbol
         X
     sort
      identifier
       symbol
        simpleSymbol
         Y
     )
    )
    )
   )
  theory_attribute
   :notes
   string
    "A schematic version of the theory of functional arrays with extensionality."
  theory_attribute
   :definition
   string
    "For every expanded signature Sigma, the instance of ArraysEx with that\nsignature is the theory consisting of all Sigma-models that satisfy all axioms of the form below, for all sorts s1, s2 in Sigma:\n- (forall ((a (Array s1 s2)) (i s1) (e s2)) (= (select (store a i e) i) e))\n- (forall ((a (Array s1 s2)) (i s1) (j s1) (e s2))\n(=> (distinct i j) (= (select (store a i e) j) (select a j))))\n- (forall ((a (Array s1 s2)) (b (Array s1 s2))) (=>\n         (forall ((i s1)) (= (select a i) (select b i))) (= a b))) "
  theory_attribute
   :values
   string
    "For all sorts s1, s2, the values of sort (Array s1 s2) are either abstract or have the form (store a i v) where\n- a is value of sort (Array s1 s2),\n- i is a value of sort s1, and\n- v is a value of sort s2."
  )
 <EOF>
