Map{ "1" |-> "a", "2" |-> "b" };
OrderedSet{ 1, 2, 4 };
lambda x : double in x*x*x;
if s->hasMatch("[a-z]+") then s->firstMatch("[a-z]+") else null endif;
if s->hasMatch("[a-z]+") then s->firstMatch("[a-z]+") else s endif;

/* dot notation can be used instead, if you prefer: */ 
if s.hasMatch(r) then s.firstMatch(r) else s endif;

s->select( x | x >= 0)->collect( y | y*y )->sum();
s->iterate( x; acc = Set{} | acc->including(x*x) );
2*x - 3*y + 4*z;

/* This is now correctly parsed as (2*x - 3*y) + 4*z
The original version of the grammar gave 2*x - (3*y + 4*z) */ 


context Company inv: self.employee->forAll( e1, e2 : Person | e1 <> e2 implies e1.forename <> e2.forename)

context Company inv: self.employee->exists( e1, e2 : Person | e1 <> e2)


context SET inv: let variableReference : VariableReference = self.referenceOwner.oclAsType(VariableReference), queryResult : EObjectReference = variableReference.referencedVariable.oclAsType(QueryVariable).queryResult.oclAsType(EObjectReference) in if self.referenceOwner.oclIsKindOf(EObjectReference) then self.referenceOwner.oclAsType(EObjectReference).elements->size() = 1 else if self.referenceOwner.oclIsKindOf(VariableReference) then if variableReference.referencedVariable.oclIsKindOf(QueryVariable) then if variableReference.referencedVariable.oclAsType(QueryVariable).queryResult.oclIsKindOf(EObjectReference) then queryResult.elements->size() = 1 else false endif else true endif else true endif endif

context Birthday inv: self.date <> null

context Birthday inv: self.levels->first().name = 'Silver'

context Birthday inv: self.cards->select(c | c.valid)->first().id

context Birthday inv: self.customers->any(c | c.age > 18).id

context Birthday inv: bodyEvals->at(1).environment = self.environment->addAll( bindings )

parts->select(valid)
context Body inv: parts->select(x | x.valid)
context Body inv: parts->collect(element)
context Body inv: parts->collect(element | element.weight)
context Body inv: c.Job->select(salary > 10000).employee->asSet()
context EvalEnvironment inv: bindings->collect(name)->forAll( name: String | bindings->collect(name)->isUnique(name))
context EvalEnvironment inv: self->iterate( elem; acc : Integer = 0 | if elem = object then acc + 1 else acc endif)
context CollectionLiteralExp inv: type.oclAsType (CollectionType).elementType = part->iterate (p; c : Classifier = OclVoid | c.commonSuperType (p.type))
context Schedule inv: days->forAll( hours >=10 )
context LoopExp inv: self.iterator->forAll(initExpression->isEmpty())
context IteratorExp inv: self.iterator->forAll(type = source.type.oclAsType (CollectionType).elementType)
context Test inv: days->forAll(d: Day | d.hours >= 10)
context Department inv: self.controls->forAll( p:Project | self.manages.employee.worksOn->select(hours >= 5)->includes(p) )


context Tree
inv: Tree.allInstances()->forAll(var | var.fruit->size() <= self.capacity)
aSet.name
aSet->collect(name)