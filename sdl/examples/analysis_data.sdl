{		        COPYRIGHT © 1985, 1996 BY
{	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
{
{ THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
{ ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
{ INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
{ COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
{ OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
{ TRANSFERRED.
{
{ THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
{ AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
{ CORPORATION.
{
{ DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
{ SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.

{++
{ FACILITY:
{   VAX Source Code Analyzer: Analysis Data File
{
{ ABSTRACT:
{   This module defines the structure of the SCA Analysis Data File,
{   which is generated by VAX language processors, and interpreted by
{   the VAX Source Code Analyzer.
{
{ ENVIRONMENT:
{   User mode
{
{ DISCLAIMER:
{   This interface is not supported by Digital.  While the SCA Analysis Data
{   File interface is believed to be correctly described here, Digital does
{   not guarantee that all descriptions in this definition file are correct
{   and complete.  Also, while this interface is expected to be reasonably
{   stable across releases, Digital cannot guarantee that it will not
{   change in future releases of VAX SCA, VAX VMS, the VAX language
{   processors, or other software.  Upward-compatible additions to this
{   interface are more likely than incompatible changes, but individuals
{   and organizations who use this interface stand some risk that their
{   work will be partially or wholly invalidated by future releases of 
{   VAX SCA or other Digital software.  Digital reserves the right to
{   make future incompatible changes to the SCA Analysis Data File interface.
{
{ AUTHOR:
{   Mark Arsenault, Technical Languages and Environments, SCA Project
{
{ CREATION DATE: June 1985
{
{ CURRENT STATUS:
{
{   Eleventh Draft  --  10 October 1986
{--

{++
{		MODIFICATION HISTORY
{
{ Changes from the tenth to the eleventh draft:
{
{   - Removed ancient Modification History.
{   - The eleventh draft is incompatible with previous versions of the data
{     file.  The major-version-number has been incremented.
{   - Added the SDL FILL attribute to all unused fields.  This keeps these
{     field definitions out of the SDL output file, and hence makes them
{     unusable.  Remember, all unused fields must be zero.
{   - The format of the Module Header Extension has been completely overhauled.
{     Command-kinds have been added.  The compilation-timestamp field has been
{     moved to the Module Header (HDR_COMP_TIMESTAMP).
{   - A new field has been added to the module header, HDR_GST_LONG_NOT_WORD.
{     This field must be zero for all compilers except Ada.
{   - The following field-kinds have been removed: KIND_BODY, KIND_INST_REF,
{	KIND_INST_REPLACE.
{   - The following field-kinds have been added: KIND_DO_NOT_USE_*,
{	KIND_GEN_SPEC, KIND_COMMENT, KIND_TEXT, KIND_PARENT, KIND_DERIVATION_OF,
{	KIND_INSTANTIATION_OF.
{   - The following field-kinds have been renamed: 
{	KIND_RENAMING_EXPR => KIND_RENAMES,
{	KIND_REF_CLASS => KIND_REF_CLASS_REPL and KIND_REF_CLASS_NOREPL.
{   - The following declaration-classes have been removed: DC_VARIABLE_RENAMES,
{	DC_ROUT_RENAMES, DC_MOD_RENAMES, DC_EXCP_RENAMES, DC_ROUT_IMPLE,
{	DC_ENTRY_POINT_IMPLE, DC_ROUT_IMPLE_TEMPL, MOD_IMPLE_TEMPL,
{	DC_DERIVED_ROUT_IMPLE, DC_GEN_IN, DC_GEN_IN_OUT, DC_GEN_ROUT_SPEC,
{	DC_GEN_ROUT_IMPLE, DC_TASK_SPEC, DC_BINARY_OP, DC_UNARY_OP.
{   - The following declaration-classes have been added: DC_ENUM_LIT_SPEC,
{	DC_ARRAY_COMP_SPEC, DC_RECORD_COMP_SPEC, DC_FUNC_IMPLE, DC_FUNC_SPEC,
{	DC_PROC_IMPLE, DC_PROC_SPEC, DC_MAP, DC_HANDLER, DC_GEN_FUNC_SPEC,
{	DC_GEN_FUNC_IMPLE, DC_GEN_PROC_SPEC, DC_GEN_PROC_IMPLE,
{	DC_GEN_FORMAL_FUNC, DC_GEN_FORMAL_PROC, DC_GEN_FORMAL_TYPE,
{	DC_GEN_FORMAL_VARIABLE, DC_TASK_TYPE_SPEC.
{   - The following declaration-classes have been renamed:
{   - The following node_kinds have been removed: NODE_RENAMING, NODE_STUB,
{	NODE_REPLACEMENT.
{   - The following node-kinds have been added: NODE_RETURN_VALUE,
{	NODE_COMMENT, NODE_NAME_IN_COMMENT, NODE_KEYWORD.
{   - The following command-kinds has been added: CMDKIND_TEXT_B.
{   - The CC_CANNOT_FIND_REF field has been added to the $ANA_CALL_CLASS field.
{   - The RA_ENTRY_POINT field has been added to the $ANA_ROUT_ATTRI field.
{   - The DA_IS_SEPARATE field has been added to the $ANA_DECL_ATTRI field.
{--

{++
{		TABLE OF CONTENTS
{
{	    Overview of the SCA Analysis Data File
{	    Module Header
{	    Module Header Extension
{	    Name Table
{	    File Table
{	    Global Symbol Table
{	    Event Stream
{		- basic definitions
{		- lexical information
{		- semantic information
{--



{++
{	OVERVIEW OF THE SCA ANALYSIS DATA FILE
{
{   An SCA Analysis Data File can contain multiple SCA Data Modules.
{   Successive data modules are simply concatenated together.  Each data 
{   module is completely self-contained.  Each data module is block aligned.
{
{   An SCA Data Module consists of five parts:
{	- Module Header
{	- Module Header Extension
{	- Name Table
{	- File Table
{	- Global Symbol Table
{	- Event Stream
{
{   Each of these parts begin on a block boundary.  Within a given part of the
{   data module, blocks are crossed, without any padding or alignment.
{
{   The beginning of an SCA Data Module is the Module Header.  The other 
{   parts of the data file can be in any order.  The Module Header has the
{   information needed to read the rest of the data module.  For example, 
{   the Module Header has a field (ANA$L_HDR_ES_OFFSET) which contains 
{   the block offset of the beginning of the Event Stream from the beginning 
{   of the data module.  Similar fields describe the location of the beginning
{   of the other parts of the data module.
{--

MODULE analysis_data;

{++
{		MODULE HEADER
{
{   The Module Header consists of one block of fixed-format information.
{
{   The module header describes all the other parts of the analysis data
{   module.  Of particular interest is the Module Header Extension which is
{   an extension of the module header.
{
{   Every module has an (outermost) declaration associated with it.
{   The ANA$L_HDR_MODULE_DECL field of the module header contains the 
{   event-id of the outermost declaration SN command.  The 
{   module header extension contains both the module name string 
{   and the module declaration.  The same information is contained 
{   in the event stream in conjunction with the name table.  It is 
{   duplicated in the module header extension so that when SCA is loading 
{   a data module it can check the identity of incoming data module against
{   the identities of the modules in the library begin updated, and thereby 
{   SCA can decide if a LOAD/NOREPLACEMENT is going to fail before "normalizing"
{   the event stream.
{--
AGGREGATE module_header STRUCTURE TAG $ana PREFIX ana$;

    { The "magic value" is used to help verify that a file is an 
    { SCA Analysis  Data File.  The first longword of an SCA Data Module
    { (and hence the first longword of an SCA Analysis Data File) 
    { contains ANA$K_HDR_MAGIC_VALUE.
    {
    hdr_magic_value	LONGWORD UNSIGNED;    { Only .ANA files have this value
      CONSTANT hdr_magic_value EQUALS 180557; {  (we hope)

    { These two version numbers are used to differentiate between compatible
    { and incompatible changes to the data file.  The minor version number
    { will be incremented whenever any change occurs, and it will be reset to
    { zero when the major version number is incremented.  The major version
    { number will be incremented whenever an incompatible change to the data
    { file is made.

    hdr_major_version   WORD UNSIGNED;	      { Analysis Data File major version
      CONSTANT hdr_major_version EQUALS 1;
    hdr_minor_version	WORD UNSIGNED;	      { Analysis Data File minor version
      CONSTANT hdr_minor_version EQUALS 0;

    hdr_language	WORD UNSIGNED;	    { Language code of processor
      CONSTANT(	macro,			    {  which created the data module.
		fortran,
		bliss,
		cobol,
		basic,
		pli,
		pascal,
		c,	    { SCA has no plans to support RPG (or vice versa).
		rpg,	    { This code is here for the sake of consistency
		ada,	    { with the DST's.
		unknown,
	    	scan,
		sdl,
		epascal )
	    EQUALS 1 INCREMENT 1 PREFIX ana$ COUNTER #temp;
	  CONSTANT hdr_max_language EQUALS #temp PREFIX ana$;

	hdr_unused_1	    WORD UNSIGNED FILL;	{ reserved for future use
						{  must be zero

{		MODULE HEADER continued

    { These "offset" fields must be (re-)written at the end of the generation
    { of the data file.
    {
	hdr_mhe_offset	    LONGWORD UNSIGNED;	{ offset of the beginning of the
						{   module header extension from
						{   the beginning of the data 
						{   module in terms of blocks
	hdr_mhe_size	    LONGWORD UNSIGNED;	{ number of blocks in the 
						{   module header extension
	hdr_nt_offset	    LONGWORD UNSIGNED;	{ offset of the beginning of the
						{   Name Table from the
						{   beginning of the data module
						{   in terms of blocks
	hdr_nt_size	    LONGWORD UNSIGNED;	{ number of blocks in the Symbol
						{   Name Table
	hdr_ft_offset	    LONGWORD UNSIGNED;	{ offset of the beginning of the
						{   File Table from the
						{   beginning of the data module
						{   in terms of blocks
	hdr_ft_size	    LONGWORD UNSIGNED;	{ number of blocks in the File
						{   Table
	hdr_gst_offset	    LONGWORD UNSIGNED;	{ offset of the beginning of the
						{   Global Symbol Table from the
						{   beginning of the data module
						{   in terms of blocks
	hdr_gst_size	    LONGWORD UNSIGNED;	{ number of blocks in the Global
						{   Symbol Table

	hdr_unused_2	OCTAWORD UNSIGNED FILL; { reserved for future use
						{  must be zero

	hdr_es_offset	    LONGWORD UNSIGNED;	{ offset of the beginning of 
						{   Event Stream from the
						{   beginning of the data module
						{   in terms of blocks
	hdr_es_size	    LONGWORD UNSIGNED;	{ number of blocks in the Event
						{   Stream
	hdr_total_size	    LONGWORD UNSIGNED;	{ number of blocks in the whole
						{   data module

{		MODULE HEADER continued

    { This set of fields describe various maximum values associated with this
    { compilation.  These must be (re-)written at the end of the compilation
    {
	hdr_name_count	    LONGWORD UNSIGNED;	{ number of unique entries in
						{  the name table
	hdr_symbol_count    LONGWORD UNSIGNED;	{ number of unique symbols
						{ A symbol is a collection of
						{ "associated declarations",
						{ See the "How SCA Views Source"
						{ for more about symbols and
						{ associated declarations.
	hdr_decl_count	      LONGWORD UNSIGNED;{ number of unique declarations
	hdr_global_symbol_count	LONGWORD UNSIGNED;{ number of entries in the 
						{    Global Symbol Table
	hdr_file_count	      WORD UNSIGNED;	{ number of unique entries in 
						{  File Table
	hdr_module_count      WORD UNSIGNED;	{ number of unique connections
						{   to (other) modules
	hdr_event_count	    LONGWORD UNSIGNED;	{ number of unique events

	hdr_unused_3	OCTAWORD UNSIGNED FILL; { reserved for future use
						{  must be zero

	hdr_module_decl	    LONGWORD UNSIGNED;	{ the event number of the 
						{  module declaration
	hdr_module_decl_class BYTE UNSIGNED;	{ declaration-class of the
						{  module declaration

	hdr_unused_4	    BYTE FILL;		{ reserved for future use
						{ must be zero
	hdr_unused_5	    WORD FILL;		{ reserved for future use
						{ must be zero

{		MODULE HEADER continued

	hdr_flags   STRUCTURE TAG b;		{ module attributes:

	    { This next bit is TRUE if the names in the Name Table are
	    { sorted in alphabetically ascending order.  I don't expect any
	    { compiler to sort its names (before assigning name-id's), but if
	    { a compiler does sort them, SCA may profit from knowing about it.
	    {
	    hdr_names_are_sorted BITFIELD;

	    { This next bit is set if the data module was created using the
	    { EXTRACT MODULE command of SCA.  Compilers should clear this bit.
	    { 
	    hdr_is_extraction	BITFIELD;

	    { TRUE if the entries in the Global Symbol Table are longwords,
	    { otherwise the entries are words.  Only applicable to Ada.
	    { This field must be zero if there is no Global Symbol Table.
	    {
	    hdr_gst_long_not_word BITFIELD;

	    hdr_unused_6 BITFIELD LENGTH 4 FILL;{ reserved for future use
						{  must be zero

	    { The following several bits may have to be (re-)written at the
	    { end of the compilation.
	    {
	    hdr_infos	    BITFIELD;		{  informationals in compilation
	    hdr_warnings    BITFIELD;		{  warnings in compilation 
	    hdr_errors      BITFIELD;		{  errors in compilation 
	    hdr_fatal_errors BITFIELD;		{  fatals errors in compilation

	    { This next bit means that the compilation ended prematurely
	    { because of some reason other than a fatal-error.  An example of 
	    { this is the /ERROR_LIMIT qualifier to the BLISS compiler, which
	    { terminates the compilation whenever a particular number of errors
	    { are found.  This bit suggests that the compilation terminated
	    { gracefully, so that SCA can assume that the ANA module contains
	    { consistent information: e.g., no dangling pointers.  This is
	    { in contrast with the HDR_FATAL_ERROR bit which suggests that
	    { the ANA module may be a mess.
	    {
	    hdr_ended_prematurely BITFIELD;
	    hdr_unused_7 BITFIELD LENGTH 4 FILL;{ reserved for future use
						{  must be zero

	    { The following several bits several bits are indicate the level
	    { of SCA support that a compiler has.  All officially supported
	    { compilers should set all of these bits all the time.  A
	    { particular bit, such a the SEMANTIC bit means, not that a 
	    { compilation has semantic events, but that if a compilation
	    { has semantic events then the compiler will tell SCA about
	    { them.
	    {
	    hdr_file_in	    BITFIELD;		{  file input info included
	    hdr_file_out    BITFIELD;		{  file output info included
	    hdr_lexical	    BITFIELD;		{  lexical information included
	    hdr_semantic    BITFIELD;		{  semantic information included
	    hdr_fetch_store BITFIELD;		{  ref-class info included
	    hdr_macro	    BITFIELD;		{  macro-expansion info included

	    hdr_unused_8 BITFIELD LENGTH 32-^ FILL;{  reserved for future use
	    END hdr_flags;			   {   must be zero

    HDR_COMP_TIMESTAMP      QUADWORD;		{ Date-time of the compilation
						{  in VMS binary format

    hdr_unused_9 CHARACTER LENGTH 512-. FILL;	{ reserved for future use
						{  must be zero
    END module_header;

{	MODULE HEADER EXTENSION
{
{   The Module Header Extension is an extension to the module header.
{
{   The Module Header Extension (MHE) consists of MHE Commands.  The
{   beginning of the MHE is ANA$L_HDR_MHE_OFFSET blocks from the
{   beginning of the Data Module.  The end of the MHE is designated
{   by an End of MHE Command.
{
{   MHE Commands can appear in any order.  (Ada multiple
{   Reuse Timestamp Commands 
{--

{++
{   $ANA_GENERIC_MHE - ANA Generic Module Header Extension Command
{
{   Describes the fields that are common to all ANA MHE Commands.
{--
    AGGREGATE generic_mhe STRUCTURE TAG $ana PREFIX ana$;
	genmhe_cmdkind BYTE UNSIGNED;	    { command kind

	CONSTANT min_mhe_cmdkind EQUALS 1 PREFIX ana$;
	CONSTANT(   cmdkind_end_of_mhe,
		    cmdkind_module_name_w,
		    cmdkind_ident_b,
		    cmdkind_processor_b,
		    cmdkind_command_line_w,
		    cmdkind_reuse_timestamp )
	    EQUALS ana$k_min_mhe_cmdkind INCREMENT 1 PREFIX ana$ COUNTER #temp;
	CONSTANT max_mhe_cmdkind EQUALS #temp PREFIX ana$;

	END generic_mhe;

{++
{   $ANA_END_OF_MHE - ANA End Of Module Header Extension Command
{
{   The End Of MHE Command marks the end of the Module Header Extension.
{--
    AGGREGATE end_of_mhe STRUCTURE TAG $ana PREFIX ana$;
	eomhe_cmdkind BYTE UNSIGNED;	    { command kind
	END end_of_mhe;

{++
{   $ANA_MODULE_NAME_W - ANA Module Name Word Command
{
{   The Module Name Word Command contains the module name string in
{   ASCIW format.
{--
    AGGREGATE module_name_w STRUCTURE TAG $ana PREFIX ana$;
	modnamew_cmdkind BYTE UNSIGNED;	    { command kind

	modnamew_name	 WORD UNSIGNED;	    { (first word of the) module name
					    { string in ASCIW format
	END module_name_w;

{++
{   $ANA_IDENT_B - ANA Ident Byte Command
{
{   The Ident Byte Command contains the object module ident string 
{   ASCIC format.
{--
    AGGREGATE ident_b STRUCTURE TAG $ana PREFIX ana$;
	identb_cmdkind BYTE UNSIGNED;	    { command kind

	identb_name    BYTE UNSIGNED;	    { (first byte of the) ident
					    { string in ASCIC format
	END ident_b;

{++
{   $ANA_PROCESSOR_B - ANA Processor Byte Command
{
{   The Processor Byte Command contains the processor ident string 
{   ASCIC format.
{--
    AGGREGATE processor_b STRUCTURE TAG $ana PREFIX ana$;
	processorb_cmdkind BYTE UNSIGNED;   { command kind

	processorb_name	   BYTE UNSIGNED;   { (first byte of the) processor
					    { ident string in ASCIC format
	END processor_b;

{++
{   $ANA_COMMAND_LINE_W - ANA Command Line Word Command
{
{   The Command Line Word Command contains the command line string 
{   ASCIW format.
{--
    AGGREGATE command_line_w STRUCTURE TAG $ana PREFIX ana$;
	cmdlinew_cmdkind BYTE UNSIGNED;	    { command kind

	cmdlinew_name    WORD UNSIGNED;	    { (first word of the) command
					    { line string in ASCIW format
	END command_line_w;

{++
{   $ANA_REUSE_TIMESTAMP - ANA Reuse Timestamop Command
{
{   The Reuse Timetamp Command contains a quadword timestamp in VMS
{   binary format of first compilation of this unit that is "compatible"
{   with the current one.
{
{   At this time, only Ada uses this command.
{--
    AGGREGATE reuse_timestamp STRUCTURE TAG $ana PREFIX ana$;
	reusetime_cmdkind BYTE UNSIGNED;    { command kind

	reusetime_timestamp    QUADWORD;    { date-time in VMS binary format
	END reuse_timestamp;

{++
{	NAME TABLE
{
{   The Name Table consists of a list of names.  Each name is in 
{   ASCIC format (i.e. the first byte contains the length of the string not
{   counting the length byte).  The names are packed together as close as
{   possible (i.e. there is no alignment between names).
{
{   The beginning of the Name Table is ANA$L_HDR_NT_OFFSET blocks from 
{   the beginning of the Data Module.  The end of the Name Table is 
{   designated by a ASCIC name count field of 255.   Hence, the zero-length
{   name string can be represented, and the longest name string is 254
{   characters long.
{
{   The NAME_COUNT field of the module header contains the number of entries
{   in the name table.  It does not include the end-of-name-table designation.
{
{   The Event Stream refers to the Name Table via "name-id"'s.
{   A name-id of N refers to the Nth name string in the Name Table.
{   The first name in the Name Table has name-id number one.
{
{   For case-insensitive languages (all of them except C), all names must be 
{   upcased in the Name Table.  Case-sensitive languages should place
{   name string in the Name Table in their original format.
{--
    CONSTANT end_of_name_table EQUALS 255 PREFIX ana$;

{++
{	FILE TABLE
{
{   The File Table consists of a list of file definitions.
{
{   The File Table describes two kinds of files: ordinary RMS files, and 
{   text library modules that are extracted from LIBRARIAN library files.
{
{   Ordinary RMS files are described via the Define File Command.  A Define File
{   Command contains a file spec in ASCIW format (i.e. the first word (not byte)
{   contains the length of the string not counting the length word), along with
{   other file information.  This file spec is the fully specified filename, 
{   complete with device name and version number, in which all wild cards and 
{   logical names (excepting concealed devices) have been resolved.  This 
{   string should be retrieved with a $NAM block from RMS via the $OPEN or
{   $SEARCH system service.  The desired string is the "Resultant String" 
{   specified by the NAM$L_RSA, NAM$B_RSS, and NAM$B_RSL fields of the $NAM 
{   block.
{
{   Text library module "files" are described via the Define Library Module
{   Command.  The Define Library Module Command contains a file-id that 
{   indicates the library file from which the library module is extracted, 
{   and the module name of the library module in ASCIC format.  Hence, the 
{   description of a  text library module requires two File Table Commands:
{   a Define File Command to describe the library file, and a Define Library
{   Module Command to describe the library module.  Both commands define a 
{   different file-id.  It is acceptable to have multiple Define Library Module
{   Commands refer to a given Define File Command, the effect of which is to 
{   not repeat the description of the library file information.
{
{   File Table Commands are packed together as close as possible (i.e. there 
{   is no alignment between commands).
{
{   The beginning of the File Table is ANA$L_HDR_FT_OFFSET blocks from 
{   the beginning of the Data Module.  The end of the File Spec Table is 
{   designated by a End of File Table Command.
{
{   The FILE_COUNT field of the module header contains the number of entries
{   in the file table.  It does not include the end-of-file-table command.
{
{   The Event Stream refers to the File Table via "file-id"'s.
{   A file-id of N refers to the Nth command in the File Table.
{   The first command in the File Table has file-id number one.
{--

{++
{   $ANA_GENERIC_FILE - ANA Generic File Table Command
{
{   Describes the fields that are common to all ANA File Table Commands.
{--
    AGGREGATE generic_file STRUCTURE TAG $ana PREFIX ana$;
	genfile_cmdkind	BYTE UNSIGNED;	{ command kind

	CONSTANT min_file_cmdkind EQUALS 1 PREFIX ana$;

	    CONSTANT(	cmdkind_define_file,
		        cmdkind_define_lmf,
			cmdkind_end_of_file_table )
	    EQUALS ana$k_min_file_cmdkind
		INCREMENT 1 PREFIX ana$ COUNTER #temp;

	CONSTANT max_file_cmdkind EQUALS #temp PREFIX ana$;
	END generic_file;

{		FILE TABLE continued

{++
{   $ANA_DEFINE_FILE - ANA Define File Command
{
{   Describes an RMS file.  The "RMS_FFB", "RMS_EBK", "RMS_CDT", and
{   "RMS_RFO" fields are optional.  A field is designated "not provided"
{   via the value -1.  
{--
    AGGREGATE define_file STRUCTURE TAG $ana PREFIX ana$;
	deffile_cmdkind	BYTE UNSIGNED;		{ command kind

	deffile_rms_ffb	WORD UNSIGNED;		{ first free byte of the 
						{  end-of-file block
						{  (from XAB$W_FFB in $XABFHC)
	deffile_rms_ebk	LONGWORD UNSIGNED;	{ end-of-file block number
						{  (from XAB$L_EBK in $XABFHC)

	deffile_rms_cdt QUADWORD UNSIGNED;	{ creation date-time of the file
						{  (from XAB$Q_CDT in $XABDAT)
    
	deffile_flags	BITFIELD LENGTH 8;	{ reserved for future use: MBZ
	deffile_rms_rfo	BYTE UNSIGNED;		{ file organization and command
						{  format (from XAB$B_RFO in 
						{  $XABFHC)

	deffile_spec	WORD UNSIGNED;		{ (first word of the) file 
						{  spec string in ASCIW format

	deffile_base CHARACTER LENGTH 0 TAG z;	{ beginning of file spec string
	END define_file;

{++
{   $ANA_DEFINE_LIB_MODULE - ANA Define Library Module Command
{
{   Describes a text library module.
{--
    AGGREGATE define_lib_module STRUCTURE TAG $ana PREFIX ana$;
	deflm_cmdkind	BYTE UNSIGNED;		{ command kind

	deflm_file_id	WORD UNSIGNED;		{ file-id of the library file 
						{  in which the module is 
						{  found -- must refer to a 
						{  Define File Command
	deflm_idt	QUADWORD UNSIGNED;	{ date-time of the insertion
						{  of this module into the
						{  text library
	deflm_name	BYTE UNSIGNED;		{ (first byte of the) text 
						{  library module name string 
						{  in ASCIC format
	deflm_base CHARACTER LENGTH 0 TAG z;	{ beginning of name string
	END define_lib_module;

{++
{   $ANA_END_OF_FILE_TABLE - ANA End of File Table Command
{
{   The End of File Table Command indicates the end of the File Table.
{--
    AGGREGATE end_of_file_table STRUCTURE TAG $ana PREFIX ana$;
	eoft_cmdkind	BYTE UNSIGNED;		{ command kind
	END end_of_file_table;

{++
{	GLOBAL SYMBOL TABLE
{
{   The Global Symbol Table provides a means by which other data modules
{   can refer to specific events in this data module (with an extra layer
{   of indirection to assist Ada's selective recompilation).
{
{   The Global Symbol Table is only produced by the Ada compiler.
{
{   The Global Symbol Table consists of an array of event stream numbers.
{   Each entry in the array is either obsolete (indicated by a value of zero) 
{   or is the event stream number of the beginning of a declaration of
{   a globally visible symbol.
{
{   The beginning of the Global Symbol Table is ANA$L_HDR_GST_OFFSET blocks 
{   from the beginning of the Data Module.  The number of entries in the
{   Global Symbol Table is contained in the ANA$L_HDR_GLOBAL_SYMBOL_COUNT
{   field of the module header.
{
{   The size of each array entry is determined by the setting of the
{   HDR_GST_LONG_NOT_WORD field in the Module Header.
{
{   The Global Symbol Table serves two purposes.  First, unlike most other
{   languages which have a flat name space (that is visible at any given
{   point in a program), on account of overloading Ada can have several
{   symbols with the same name visible at a given point in a program.
{   Consequently, module and name is not enough to refer to symbols across
{   modules.  Ada needs to refer a particular declaration in a particular
{   module.
{
{   The Ada compiler automatically recompiles library units that have
{   dependencies on a library unit that has changed since its last
{   compilation.  The Ada compiler will be smart enough so that a
{   dependent library unit will not be recompiled if the actual entities
{   on which the library unit depends have not changed, even though the
{   library unit that contains them has changed.
{
{   The second problem solved by the Global Symbol Table is:  Pointers
{   to global visible symbols in one library unit from a second library 
{   unit must remain valid even though the first library unit has been
{   recompiled.  
{
{   This problem is solved by pointing to declarations by means of
{   indexes into the appropriate Global Symbol Table, rather than by
{   pointing directing in the event stream.  When the Ada compiler 
{   recompiles a library unit, as much as possible, it reuses Global Symbol
{   Table indexes (gst-id).  If a globally visible symbol becomes non-existant
{   as as a result of a recompilation, the gst-id is set to zero.  If new
{   globally visible symbols are added as a result of a recompilation, they
{   are added to the Global Symbol Table at the end of the original table.
{--

{++
{	EVENT STREAM
{
{   The event stream contains the bulk of the information in a SCA Data Module.
{   It contains lexical information and semantic information.
{
{   See the design note "How the VAX Source Code Analyzer Views Source Code"
{   for a conceptual description of the information that is represented in 
{   the event stream.
{
{   The Event Stream has some state information.  In particular, at any point
{   in the Event Stream there is a current file, a current line number, and a
{   current command number.
{
{   The Event Stream contains pointers into the Name Table, the 
{   File Table, and the Global Symbol Table, via name-id's, file-id's,
{   and gst-id's.  A name-id of N refers to the Nth name string in the 
{   Name Table.  For example, the fourth name string in the 
{   Name Table is assigned a name-id of four.  Similarly, a file-id 
{   of N refers to the Nth file in the File Table.  A gst-id of N refers
{   to the Nth entry in the Global Symbol Table.
{
{   The Event Stream also contains pointers into itself;  that is, the Event
{   Steam is explicitly self-referential.  Conceptually, one event points
{   at another event.  In this instance, one event stream command can have
{   a word-sized or a longword-sized field that contains the event stream
{   number of another event stream command.  This event stream number is
{   called an event-id.  The first event in an event stream has event-id one.
{
{   Each command begins with a field that contains a command kind code,
{   which indicates which kind of event stream command it is.
{
{   The end of the event stream is indicated via an End of Event Stream Command.
{
{   The EVENT_COUNT field of the module header contains the number of commands
{   in the event stream.  It does not include the end-of-event-stream command.
{--


{++
{   $ANA_GENERIC_EVENT - ANA Generic Event Command
{
{   Describes the fields that are common to all SCA Data Module Event Stream
{   Commands.
{--
    AGGREGATE generic_event STRUCTURE TAG $ana PREFIX ana$;
	genevent_cmdkind  BYTE UNSIGNED;		{ command kind

	CONSTANT min_event_cmdkind EQUALS 1 PREFIX ana$;

	    CONSTANT(	cmdkind_eoes,
			cmdkind_setfilew,
			cmdkind_setfilel,
			cmdkind_setcapfilew,
			cmdkind_setcapfilel,
			cmdkind_setlinew,
			cmdkind_setlinel,
			cmdkind_setrecw,
			cmdkind_setrecl,
			cmdkind_incrline,
			cmdkind_incrlineb,
			cmdkind_incrlinew,
			cmdkind_infile,
			cmdkind_outfile,
			cmdkind_enamew,
			cmdkind_enamel,
			cmdkind_cddext,
			cmdkind_cddbeg,
			cmdkind_cddend,
			cmdkind_macactbeg,
			cmdkind_macactdel,
			cmdkind_macactend,
			cmdkind_macexpbeg,
			cmdkind_macexpend,
			cmdkind_ccbeg,
			cmdkind_ccthen,
			cmdkind_ccelse,
			cmdkind_ccend,
			cmdkind_lexloc,
			cmdkind_textb,
			cmdkind_sn,
			cmdkind_fsnw,
			cmdkind_fsnl
			  )
	   EQUALS ana$k_min_event_cmdkind INCREMENT 1 PREFIX ana$ COUNTER #temp;
	CONSTANT max_event_cmdkind EQUALS #temp PREFIX ana$;

	END generic_event;


{++
{  $ANA_END_OF_STREAM - ANA End of Event Stream Command
{
{   The End of Event Stream Command marks the end of the event stream.
{--
    AGGREGATE end_of_stream STRUCTURE TAG $ana PREFIX ana$;
	eoes_cmdkind	BYTE UNSIGNED;		{ command kind
	END end_of_stream;

{	    LEXICAL INFORMATION

{++	    SET SOURCE POSITION COMMANDS
{
{   This series of commands are used to set the file, record, and line number
{   that are current in the event stream.  
{
{   These commands are similar in function to their DST record look-alikes.
{   One difference between SCA and the DST's is that instead of containing 
{   a file-id as it does in the DST's, the SCA Set File Command contains
{   a pointer to an ANA Input File Command.  It is the Input File Command
{   that contains the file-id.  This allows SCA to not only tell in which
{   file an event took place, but which, for example, BLISS REQUIRE declaration
{   "caused" that event.
{--

{++
{   $ANA_SET_FILE_W - ANA Set File Word Command
{
{   The Set File Word Command specifies which file is current in the 
{   event stream, using a word-sized field.
{
{   The current line number is not affected by the Set File Command.
{
{   The current record number is set to the record number that was current 
{   when this file was most recently current.  If this is the first time
{   file has been set, the record number is set to zero.  Consequently, 
{   the first Set File Command for a given input-file will usually be
{   followed by a Increment Line Number Command.
{
{   SCA will interpret events that take place a record number zero as having
{   come out of nowhere (actually, as having come out of inner compiler space).
{   This will give C an opportunity to describe macros that are defined on
{   the CC command line.
{
{   This record number defaulting can be overridden with the Set Record Command.
{--
    AGGREGATE set_file_w STRUCTURE TAG $ana PREFIX ana$;
	setfilew_cmdkind	BYTE UNSIGNED;	{ command kind

	setfilew_input_file	WORD UNSIGNED;	{ event stream number of
						{ a Input File Commmand
	END set_file_w;

{++
{   $ANA_SET_FILE_L - ANA Set File Long Command
{
{   The Set File Long Command specifies which file is current in the 
{   event stream, a using longword-size field.
{--
    AGGREGATE set_file_l STRUCTURE TAG $ana PREFIX ana$;
	setfilel_cmdkind	BYTE UNSIGNED;		{ command kind

	setfilel_input_file LONGWORD UNSIGNED;	{ event stream number of
						{ a Input File Commmand
	END set_file_l;

{	    SET SOURCE POSITION COMMANDS continued

{++
{   $ANA_SET_CAP_FILE_W - ANA Set Captured File Command Word
{
{   The Set Captured File Command indicates which file is "captured" and
{   the difference in record numbers between the captured file and the
{   original file (the one that is described using the Set File Command).
{
{   This command exists exclusively for Ada.  The Ada compiler creates a
{   copy of a source file and saves that copy in the ACS Library.  It is
{   this copy that is referred to as the "captured file".
{--
    AGGREGATE set_cap_file_w STRUCTURE TAG $ana PREFIX ana$;
	setcapfilew_cmdkind	BYTE UNSIGNED;	{ command kind
	setcapfilew_output_file  WORD UNSIGNED;	{ file-id of the captured file

	{ the original source file is delta-records greater than the record
	{ number of the captured source file.
	{
	setcapfilew_delta_records WORD;
	END set_cap_file_w;

{++
{   $ANA_SET_CAP_FILE_L - ANA Set Captured File Command Long
{
{   The Set Captured File Long Command indicates which file is "captured" and
{   the difference in record numbers between the captured file and the
{   original file, using longword-sized fields
{--
    AGGREGATE set_cap_file_l STRUCTURE TAG $ana PREFIX ana$;
	setcapfilel_cmdkind	BYTE UNSIGNED;	    { command kind
	setcapfilel_output_file  LONGWORD UNSIGNED; { file-id of the captured file

	{ the original source file is delta-records greater than the record
	{ number of the captured source file.
	{
	setcapfilel_delta_records LONGWORD;
	END set_cap_file_l;

{++
{   $ANA_SET_LINE_W - ANA Set Line Word Command
{
{   The Set Line Word Command specifies which compiler listing 
{   line number is current in the event stream.
{--
    AGGREGATE set_line_w STRUCTURE TAG $ana PREFIX ana$;
	setlinew_cmdkind    BYTE UNSIGNED;	{ command kind
	setlinew_number	    WORD UNSIGNED;	{ compiler listing line number
	END set_line_w;

{++
{   $ANA_SET_LINE_L - ANA Set Line Long Command
{
{   The Set Line Long Command specifies which compiler listing 
{   line number is current in the event stream.
{--
    AGGREGATE set_line_l STRUCTURE TAG $ana PREFIX ana$;
	setlinel_cmdkind    BYTE UNSIGNED;	{ command kind
	setlinel_number	    LONGWORD UNSIGNED;	{ compiler listing line number
	END set_line_l;

{	    SET SOURCE POSITION COMMANDS continued

{++
{   $ANA_SET_RECORD_W - ANA Set Record Word Command
{
{   The Set Record Word Command specifies which source file record number is 
{   current in the event stream.
{--
    AGGREGATE set_record_w STRUCTURE TAG $ana PREFIX ana$;
	setrecw_cmdkind	BYTE UNSIGNED;		{ command kind
	setrecw_number	WORD UNSIGNED;		{ source file record number
	END set_record_w;

{++
{   $ANA_SET_RECORD_L - ANA Set Record Long Command
{
{   The Set Record Long Command specifies which source file record number is 
{   current in the event stream.
{--
    AGGREGATE set_record_l STRUCTURE TAG $ana PREFIX ana$;
	setrecl_cmdkind	BYTE UNSIGNED;		{ command kind
	setrecl_number	LONGWORD UNSIGNED;	{ source file record number
	END set_record_l;

{++	    INCREMENT SOURCE POSITION COMMANDS
{
{   This series of commands are used to increase the record and line number
{   that are current in the event stream.  
{--

{++
{   $ANA_INCR_LINE - ANA Increment Line Command
{
{   The Increment Line Command increments the current line number by one.
{
{   This command effects both the compiler listing line number and the source
{   file record number.
{--
    AGGREGATE incr_line STRUCTURE TAG $ana PREFIX ana$;
	incrline_cmdkind    BYTE UNSIGNED;	{ command kind
	END incr_line;


{++
{   $ANA_INCR_LINE_B - ANA Increment Line Byte Command
{
{   The Increment Line Byte Command increments the current line number
{   by a byte value.
{
{   This command effects both the compiler listing line and the source
{   file record number.
{--
    AGGREGATE incr_line_b STRUCTURE TAG $ana PREFIX ana$;
	incrlineb_cmdkind   BYTE UNSIGNED;	{ command kind

	incrlineb_delta	    BYTE UNSIGNED;	{ number of lines to increment
	END incr_line_b;


{++
{   $ANA_INCR_LINE_W - ANA Increment Line Word Command
{
{   The Increment Line Word Command increments the current line number
{   by a word value.
{
{   This command effects both the compiler listing line number and the source
{   file record number.
{--
    AGGREGATE incr_line_w STRUCTURE TAG $ana PREFIX ana$;
	incrlinew_cmdkind   BYTE UNSIGNED;	{ command kind

	incrlinew_delta	    WORD UNSIGNED;	{ number of lines to increment
	END incr_line_w;

{++	    EXPANDED NAME COMMANDS
{
{   The Expanded Name Commands are used to describe expanded names.
{
{   A expanded name is described via a list of Expanded Name Commands.
{   The end of the list of expanded name components is indicated by the
{   appearance of the first command that is not a Expanded Name Command.
{
{   Note that Expanded Name Commands are not used to describe component
{   selection (which looks like X[Y] or X.Y depending on one's language).
{   Component selection is described via the component-selection 
{   semantic nodes.
{
{   The Expanded Name Commands are used in conjunction with the 
{   the CDD Extract Command.
{--


{++
{  $ANA_EXPANDED_NAME_W - ANA Expanded Name Word Command
{
{  The Expanded Name Word Command indicates a component of a expanded name 
{  list, using a word-sized field.
{
{--
    AGGREGATE expanded_name_w STRUCTURE TAG $ana PREFIX ana$;
	enamew_cmdkind	BYTE UNSIGNED;		{ command kind

	enamew_name_id	WORD UNSIGNED;		{ name-id for expanded name 
						{  component
	END expanded_name_w;


{++
{  $ANA_EXPANDED_NAME_L - ANA Expanded Name Long Command
{
{  The Expanded Name Long Command indicates a component of a expanded name 
{  list, using a longword-sized field.
{--
    AGGREGATE expanded_name_l STRUCTURE TAG $ana PREFIX ana$;
	enamel_cmdkind	BYTE UNSIGNED;		{ command kind

	enamel_name_id	LONGWORD UNSIGNED;	{ name-id for expanded name 
						{  component
	END expanded_name_l;

{++
{   $ANA_INPUT_FILE - ANA Input File Command
{
{   The Input File Command indicates the inclusion of a file into a 
{   compilation.  This is to be used for files that are specified on 
{   compiler command lines, include (require) files, and pre-compiled
{   files (e.g., BLISS LIBRARY, PASCAL ENVIRONMENT).
{
{   Note that the Input File Command is not a substitute for the
{   Set File Command.  The Set File Command (along with the Set Line, 
{   Set Record, and Increment Line Command) is used to describe the 
{   mapping between compilation listing line numbers and source records.
{   The Input File Command is used to indicate where in the lexical 
{   stream a compiler made the decision to include a file into a 
{   compilation.
{
{   The following is a typical event stream segment (for a source line 
{   which contains an FORTRAN INCLUDE statement):
{
{	Incr Line Num
{	Input File	file-id	    include-file  
{	Set File	ptr-to-input-file-cmd	(record number defaults to zero,
{	Incr Line Num				 and is incremented to one)
{
{   Note in particular that the Input File Command comes before the 
{   Set File Command, indicating that the INCLUDE statement occurred in
{   the "original" source file.  The Set File Command points at the 
{   Input File Command, which contains the file-id.  When the INCLUDE File is 
{   exhausted and the input stream reverts back to the "original" source file,
{   the event stream segment looks like:
{
{	Set File	file-id  (of the "original" file)
{	Incr Line
{
{   After this Set File Command, the current line number is that of the last
{   line of the INCLUDE File, and the current record number is that which has
{   the INCLUDE statement in the "original" file.  Hence, the Increment Line
{   Number Command gets us to the first line (and record) after the one
{   with the INCLUDE statement.
{
{   The Input File Command is can also be used to indicate a reference to 
{   precompiled file, such as a BLISS LIBRARY declaration or a PASCAL
{   ENVIRONMENT attribute.  Such a use of an Input File Command must be
{   augmented with a Define Module Command and Load Commands if declarations
{   in that precompiled module are brought into the module currently being
{   compiled.
{--
    AGGREGATE input_file STRUCTURE TAG $ana PREFIX ana$;
	infile_cmdkind	BYTE UNSIGNED;		{ command kind

	infile_file_id	WORD UNSIGNED;		{ file-id of the file being
						{  brought into the compilation
	infile_file_class BYTE UNSIGNED;	{ file class
          
	  CONSTANT min_infile_class EQUALS 1 PREFIX ana$;
	  CONSTANT( cmdline_infile,		{  most common input file class
		    precompiled_infile,		{  result of a precompilation
		    include_infile,		{  e.g., BLISS REQUIRE file
		    cdd_infile )		{  CDD file
		EQUALS ana$k_min_infile_class 
		    INCREMENT 1 PREFIX ana$ COUNTER #temp;
	  CONSTANT max_infile_class EQUALS #temp PREFIX ana$;
	END input_file;

{++
{   $ANA_OUTPUT_FILE - ANA Output File Command
{
{   The Output File Command describes the file that is the result of a
{   compilation.
{
{   It is possible to have more than Output File Command in a module.
{   As an example, consider that PASCAL statement:  PASCAL/OBJECT/ENVIRONMENT
{   which produces an object file and pre-compiled environment file.  
{   Both of these files should be described in the event stream.
{
{   The Output File Command is unique in that it's particular location
{   in the event stream (relative to other events) is not relevant.
{--
    AGGREGATE output_file STRUCTURE TAG $ana PREFIX ana$;
	outfile_cmdkind	BYTE UNSIGNED;		{ command kind

	outfile_file_id	WORD UNSIGNED;		{ file-id of the output file 

	outfile_file_class BYTE UNSIGNED;	{ file class

	  CONSTANT min_outfile_class EQUALS 1 PREFIX ana$;
	  CONSTANT( object_outfile,		{  most common output file class
		    precompiled_outfile,	{  result of a precompilation
		    text_outfile,		{  SDL creates text files
		    diagnostic_file,		{  LSE diagnostc file
		    listing_file,		{  listing file
		    analysis_data_file,		{  a .ANA describes itself
		    captured_source_file )	{  see Captured Source File Cmd
		EQUALS ana$k_min_outfile_class
		    INCREMENT 1 PREFIX ana$ COUNTER #temp;
	  CONSTANT max_outfile_class EQUALS #temp PREFIX ana$;
	END output_file;

{++	    CDD COMMANDS
{
{   SCA wants to know three things about use of CDD definitions by compilers:
{	- the pathname of the CDD object that is extracted
{	- the beginning of the "expansion" of the CDD object in the event stream
{	- the end of the "expansion" of the CDD object in the event stream
{
{   CDD pathnames are described in Analysis Data File as a list of name-id's,
{   using the CDD Extract Command in combination with the Expanded Name Command.
{-


{++
{  $ANA_CDD_EXTRACT - ANA CDD Extract Command
{
{  The CDD Extract Command indicates the extraction of a command from the CDD
{  by a compiler.
{
{  The pathname of the CDD command is denoted by one or more Expanded Name
{  Commands that directly follow the CDD Extract Command.
{
{  The pathname of interest is the "full pathname", as opposed to the relative
{  pathname that is specified in the DICTIONARY statement.
{--
    AGGREGATE cdd_extract STRUCTURE TAG $ana PREFIX ana$;
	cddext_cmdkind	BYTE UNSIGNED;		{ command kind
	END cdd_extract;


{++
{   $ANA_CDD_EXP_BEGIN - ANA CDD Expansion Begin Command
{
{   The CDD Expansion Begin Command marks the beginning of the expansion of a 
{   CDD command extraction.  A CDD Expansion Begin Command must be matched with 
{   CDD Expansion End Command.
{--
    AGGREGATE cdd_exp_begin STRUCTURE TAG $ana PREFIX ana$;
	cddexpbeg_cmdkind   BYTE UNSIGNED;	{ command kind
	END cdd_exp_begin;


{++
{   $ANA_CDD_EXP_END - ANA CDD Expansion End Command
{
{   The CDD Expansion End Command marks the end of the expansion of 
{   a CDD command extraction.
{--
    AGGREGATE cdd_exp_end STRUCTURE TAG $ana PREFIX ana$;
	cddexpend_cmdkind   BYTE UNSIGNED;	{ command kind
	END cdd_exp_end;

{++	    MACRO COMMANDS
{
{   SCA wants to know three things about the use of macros:
{	- Which macro is being referenced.
{	- The lexical extent of each of the macro actuals.  
{	- The lexical extent of the macro expansion.
{
{   The first need is met via a reference semantic node for the macro.
{   The second and third needs are met via the command in this section.
{--

{++
{   $ANA_MACRO_ACT_BEGIN - ANA Macro Act Begin Command
{
{   The Macro Actuals Begin Command marks the beginning an actuals list
{   of a macro reference.  The Macro Actuals Begin Command must be matched
{   with a Macro Actuals End Command.  
{--
    AGGREGATE macro_act_begin STRUCTURE TAG $ana PREFIX ana$;
	macactbeg_cmdkind   BYTE UNSIGNED; 	{ command kind
	END macro_act_begin;

{++
{   $ANA_MACRO_ACT_DEL - ANA Macro Actuals Delimit Command
{
{   The Macro Actuals Delimit Command delimits one macro actual from
{   another macro actual in a macro actuals list.  
{--
    AGGREGATE macro_act_del STRUCTURE TAG $ana PREFIX ana$;
	macactdel_cmdkind   BYTE UNSIGNED;	{ command kind
	END macro_act_del;

{++
{   $ANA_MACRO_ACT_END - ANA Macro Actuals End Command
{
{   The Macro Actuals End Command marks the end of an actuals list
{   of a macro reference.  
{--
    AGGREGATE macro_act_end STRUCTURE TAG $ana PREFIX ana$;
	macactend_cmdkind   BYTE UNSIGNED;	{ command kind
	END macro_act_end;

{++
{   $ANA_MACRO_EXP_BEGIN - ANA Macro Expansion Begin Command
{
{   The Macro Expansion Begin Command marks the beginning of the expansion
{   of macro.  A Macro Expansion Begin Command must be matched with 
{   Macro Expansion End Command.
{--
    AGGREGATE macro_exp_begin STRUCTURE TAG $ana PREFIX ana$;
	macexpbeg_cmdkind   BYTE UNSIGNED;	{ command kind
	END macro_exp_begin;

{++
{   $ANA_MACRO_EXP_END - ANA Macro Expansion End Command
{
{   The Macro Expansion End Command marks the end of the expansion of 
{   macro.  
{--
    AGGREGATE macro_exp_end STRUCTURE TAG $ana PREFIX ana$;
	macexpend_cmdkind   BYTE UNSIGNED;	{ command kind
	END macro_exp_end;

{++	    CONDITIONAL COMPILATION COMMANDS
{
{   The Conditional Compilation Commands are used to describe 
{   conditional compilation constructs.  For example, in BLISS
{   these constructs are called: %IF, %THEN, %ELSE, and %FI.
{--

{++
{   $ANA_COND_COMP_BEGIN - ANA Conditional Compilation Begin Command
{
{   The Conditional Compilation Begin Command marks the beginning of the test
{   expression of a compile-time condition construct.
{   
{   A Conditional Compilation Begin Command must be matched with 
{   a Conditional Compilation End Command.
{--
    AGGREGATE cond_comp_begin STRUCTURE TAG $ana PREFIX ana$;
	ccbeg_cmdkind  BYTE UNSIGNED;		{ command kind
	END cond_comp_begin;

{++
{   $ANA_COND_COMP_THEN - ANA Conditional Compilation Then Command
{
{   The Conditional Compilation Then Command separates a conditional compilation 
{   test expression from the then-clause of a compile-time condition construct.
{   
{   A Conditional Compilation Then Command must be enclosed within
{   a CCBEG-CCEND pair.
{--
    AGGREGATE cond_comp_then STRUCTURE TAG $ana PREFIX ana$;
	ccthen_cmdkind BYTE UNSIGNED;		{ command kind
	END cond_comp_then;

{++
{   $ANA_COND_COMP_ELSE - ANA Conditional Compilation Else Command
{
{   The Conditional Compilation Else Command separates a conditional compilation 
{   then-clause from a conditional compilation else-clause.
{   
{   A Conditional Compilation Else Command must be enclosed within
{   a CCTHEN-CCEND pair.
{--
    AGGREGATE cond_comp_else STRUCTURE TAG $ana PREFIX ana$;
	ccelse_cmdkind BYTE UNSIGNED;		{ command kind
	END cond_comp_else;

{++
{   $ANA_COND_COMP_END - ANA Conditional Compilation End Command
{
{   The Conditional Compilation End Command marks the end of a 
{   compile-time condition construct.
{   
{   A Conditional Compilation End Command must be matched with 
{   a Conditional Compilation Begin Command.
{--
    AGGREGATE cond_comp_end STRUCTURE TAG $ana PREFIX ana$;
	ccend_cmdkind  BYTE UNSIGNED;		{ command kind
	END cond_comp_end;

{++
{   $ANA_LEXICAL_LOCATION - ANA Lexical Location Command
{
{   The Lexical Location Command marks a location in the lexeme stream.
{
{   Lexical Location Commands only exist in order to be pointed to by
{   semantic events.
{
{   A Lexical Location Command describes a character offset, and implies
{   lexical state information via its position relative to the various
{   lexical events.  Such lexical state information includes:
{   line-record-file position, CDD extraction expansion, macro actuals
{   list, macro expansion, conditional compilation, and scopes and groups.
{
{   The first character in a record is character-offset zero.  
{--
    AGGREGATE lexical_location STRUCTURE TAG $ana PREFIX ana$;
	lexloc_cmdkind	    BYTE UNSIGNED;	{ command kind

	lexloc_char_offset  BYTE UNSIGNED;	{ character-offset in source 
						{ file record
	END lexical_location;

{++
{   $ANA_TEXT_B - ANA Text Byte Command
{
{   The Text Byte Command contains a "simple-description" that was
{   originally located within a comment in the source code.
{
{   This command is only used by PDL.
{--
    AGGREGATE text_b STRUCTURE TAG $ana PREFIX ana$;
	textb_cmdkind	    BYTE UNSIGNED;	{ command kind

	textb_text	    BYTE UNSIGNED;	{ (first byte of the) text
						{ string in ASCIC format
	END text_b;

{++	    SEMANTIC INFORMATION
{--

{++
{	    STRUCTURED FIELDS
{
{   This section defines several fields which are used in SN and FSN
{   commands.
{--


{++
{   $ANA_REF_CLASS - ANA Reference Class Field
{
{   The ANA Reference Class Field describes a reference-class.
{
{   If the reference is not a "data reference" (meaning that it is a 
{   reference to a declaration which ends up in the object code as a fetch
{   of memory, a store of memory, a passing of a memory address, or a
{   calling of a memory address), then it is a "non-data reference" which
{   is designated by the lack of a reference-class field in a reference-node.
{   Different classs of non-data references are not distinguished since in
{   most cases the class of reference can be inferred from the class of 
{   symbol being referenced. (For example, for the most part, macros can 
{   only be expanded, labels can only be gone to or exited from, linkages
{   can only be linked with, etcetera.)  Other reference classes can be
{   deciphered by noticing the place of the reference in the tree. 
{   (For example, generic instantiation references appear as children
{   of instantiation nodes.)
{
{   Data references are either of class fetch, store, address-use, or call.
{   Any of these classs can be "indirect".  Multiple levels of indirection
{   are all folded into the one indirect-bit.
{--
    AGGREGATE ref_class STRUCTURE TAG $ana PREFIX ana$;
	CONSTANT min_ref_subclass EQUALS 1;
	CONSTANT (  ref_fetch,			{ These are the sub-classs
		    ref_store,			{ of data references.  Each of 
		    ref_address,		{ these can be used in combo
		    ref_call    )		{ with the indirect bit.
	    EQUALS ana$k_min_ref_subclass 
		INCREMENT 1 PREFIX ana$ COUNTER #temp;
	CONSTANT max_ref_subclass EQUALS #temp PREFIX ana$;

	rc_subclass	BITFIELD LENGTH 3;	{ reference subclass
	rc_spares	BITFIELD LENGTH 3 FILL;	{ reserved for future use
						{  must be zero
	rc_aggregate	BITFIELD MASK;		{ aggregate reference
	rc_indirect	BITFIELD MASK;		{ indirect reference
	END ref_class;

{++
{   $ANA_DECL_CLASS - ANA Declaration Class Field
{
{   The ANA Declaration Class Field defines a declaration class.
{--
    AGGREGATE decl_class STRUCTURE TAG $ana PREFIX ana$;
	dc_decl_class	BYTE UNSIGNED;		{ the declaration-class
	END decl_class;

	{ These are the declaration classes.
	{
	CONSTANT min_decl_class EQUALS 1 PREFIX ana$;
	CONSTANT (
	    dc_accept_stmt_imple,   { (Ada) accept statement
	    dc_access_type_imple,   { access type definition 
	    dc_array_aggr_imple,    { (Ada) array aggregate 
	    dc_array_comp_imple,    { array component implementation
	    dc_array_comp_spec,	    { array component specification
	    dc_array_type_imple,    { array type implementation
	    dc_array_type_spec,	    { array type specification
	    dc_attri_func_imple,    { (Ada) x'ATTR_FUNCTION 
	    dc_attri_obj_imple,     { (Ada) x'attr_object 
	    dc_block_data_imple,    { FORTRAN BLOCK DATA 
	    dc_common_imple,	    { FORTRAN COMMON
	    dc_compiletime_imple,   { preprocessor compiletime constant imple
	    dc_compiletime_spec,    { preprocessor compiletime constant spec
	    dc_constant_imple,	    { constant implementation
	    dc_constant_spec,	    { constant specification
	    dc_discrim_imple,  	    { (Ada) discriminant 
	    dc_entry_imple,         { (Ada) entry
	    dc_enum_lit_imple,      { enumeration literal implementation
	    dc_enum_lit_spec,	    { enumeration literal specification
	    dc_enum_type_imple,     { enumeration type implementation
	    dc_enum_type_spec,      { enumeration type specification
	    dc_excp_imple,	    { (Ada) exception 
	    dc_fieldset_imple,      { (BLISS) fieldset
	    dc_field_imple,	    { (BLISS) field
	    dc_file_imple,	    { (PLI, COBOL) file constant
	    dc_file_type_imple,	    { (PASCAL) file type implementation
	    dc_file_type_spec,	    { (PASCAL) file type specification
	    dc_func_imple,	    { function implementation
	    dc_func_spec,	    { function specification
	    dc_gen_formal_func,	    { (Ada) generic formal function
	    dc_gen_formal_proc,	    { (Ada) generic formal procedure
	    dc_gen_formal_type,	    { (Ada) generic formal type
	    dc_gen_formal_variable, { (Ada) generic formal variable (object)
	    dc_gen_func_imple,	    { (Ada) generic function implementation
	    dc_gen_func_spec,	    { (Ada) generic function specification
	    dc_gen_mod_imple,       { (Ada) generic module implementation
	    dc_gen_mod_spec,	    { (Ada) generic module specification
	    dc_gen_proc_imple,	    { (Ada) generic procedure implementation
	    dc_gen_proc_spec,	    { (Ada) generic procedure specification
	    dc_handler_imple,	    { (BASIC) handler declaration
	    dc_index_constr_imple,  { index constraint implementation
	    dc_index_constr_spec,   { index constraint specificition
	    dc_label_imple,  	    { label implementation
	    dc_label_spec,  	    { label specification
	    dc_linkage_imple,	    { (BLISS) linkage implementation
	    dc_linkage_spec,	    { (BLISS) linkage specification
	    dc_macro_formal_imple,  { macro formal implementation
	    dc_macro_formal_spec,   { macro formal specification
	    dc_macro_imple,	    { macro implementation
	    dc_macro_spec,	    { macro specification
	    dc_map_imple,	    { (BASIC) MAP declarat
	    dc_mod_imple,	    { module implementation
	    dc_mod_spec,	    { (Ada) module specification
	    dc_namelist_imple,      { FORTRAN namelist
	    dc_not_declared,        { semantic error: not declared
	    dc_number_imple,	    { (Ada) number
	    dc_offset_type_imple,   { offset type (PLI-specific)
	    dc_proc_imple,	    { procedure implementation
	    dc_proc_spec,	    { procedure specification
	    dc_psect_imple,	    { psect implementation
	    dc_psect_spec,	    { psect specification
	    dc_record_aggr_imple,   { (Ada) record aggregate
	    dc_record_comp_imple,   { record component implementation
	    dc_record_comp_spec,    { record component specification
	    dc_record_type_imple,   { record type implementation
	    dc_record_type_spec,    { record type specification
	    dc_return_value_imple,  { (function) return value implementation
	    dc_return_value_spec,   { (function) return value specification
	    dc_rout_formal_imple,   { routine formal implementation
	    dc_rout_formal_spec,    { routine formal specification
	    dc_rout_spec,	    { routine specification
	    dc_scalar_type_imple,   { all scalar types (integer, etc)
	    dc_scalar_type_spec,    { all scalar types (integer, etc)
	    dc_set_type_imple,	    { set type implementation
	    dc_set_type_spec,	    { set type specification
	    dc_struct_formal_imple, { (BLISS) structure formal
	    dc_struct_imple,	    { (BLISS) structure implementation
	    dc_struct_spec,	    { (BLISS) structure spec
	    dc_subtype_imple,	    { (Ada) subtype
	    dc_syntax_macro_imple,  { (SCAN) syntax macro
	    dc_task_imple,          { (Ada) task implementation
 	    dc_task_type_imple,     { (Ada) task type implementation
 	    dc_task_type_spec,      { (Ada) task type specification
	    dc_tree_type_imple,     { (SCAN) tree type 
	    dc_treeptr_type_imple,  { (SCAN) treeptr type 
	    dc_trigger_macro_imple, { (SCAN) trigger macro
	    dc_type_imple,          { type implementation
	    dc_type_spec,           { type specification
	    dc_undeclare_spec,      { (BLISS) undeclare
	    dc_variable_imple,	    { variable implementation
	    dc_variable_spec,       { variable specification
	    dc_variant_type_imple,  { variant type implementation
	    dc_variant_type_spec )  { variant type specification

	    EQUALS ana$k_min_decl_class INCREMENT 1 PREFIX ana$ COUNTER #temp;
	CONSTANT max_decl_class EQUALS #temp PREFIX ana$;

{++
{   BLISS DECLARATION CLASSES
{
{   This section describes the mapping from BLISS declaration types to
{   SCA declaration classes (and other attributes).  This section is put
{   here to serve as an example of how to use ANA declaration classes.
{
{   BLISS Decl-Type	    ANA Decl-Class	Other ANA Attributes
{   ---------------	    --------------	--------------------
{   external		    variable-spec	global		static
{   external routine	    routine-spec	global   
{   external literal	    constant-spec	global
{   global		    variable-imple	global		static
{   global bind		    variable		global		static
{   global bind routine	    routine		global
{   global routine	    routine-imple	global
{   global literal	    constant-imple	global
{   local		    variable-imple			automatic
{   stacklocal		    variable-imple			automatic
{   register		    variable-imple			automatic
{   bind		    variable	(global or not)
{   bind routine	    routine
{   map			    variable-spec
{   literal		    constant-imple
{   own			    variable-imple		static
{   forward		    variable-spec    (global or not)	static
{   forward routine	    routine-spec     (global or not)
{   routine		    routine-imple
{   formal		    routine-formal-imple
{   label		    label-spec (the labeling reference is a label-imple)
{   structure		    structure-imple
{   macro		    macro-imple
{   structure formal	    structure-formal-imple
{   macro formal	    macro-formal-imple
{   global register	    variable-imple			automatic
{   external register	    variable-spec 			automatic
{   compiletime		    compiletime-imple
{   special function (CH$*) routine-spec	global	    predefined
{   macro (simple)	    macro-imple
{   field		    field-imple
{   fieldset		    fieldset-imple
{   linkage		    linkage-imple
{   undeclare		    undeclare-imple
{   keyword macro	    macro-imple
{   keyword macro formal    macro-formal-imple
{   psect		    psect-imple
{   not declared	    not-declared
{   (ordinary) module	    module-imple
{   library-precompilation  module-imple
{
{ Note that only Ada has module-specifications.
{--

{++
{   $ANA_DECL_ATTRI - ANA Declaration Attributes Field
{
{   The ANA Declaration Attributes Field provides more information about
{   declarations.
{
{   Most pre-defined declarations are also implicit.  An exception is
{   BLISS BUILTIN declarations, in which programmers explicitly write
{   specification declarations for symbols whose implementations are
{   pre-defined by the language.  
{--
    AGGREGATE decl_attri STRUCTURE TAG $ana PREFIX ana$;
	da_predefined	BITFIELD MASK;		{ the entity being declaration
						{ is pre-defined in the language
	da_implicit	BITFIELD MASK;		{ the declaration was not
						{ explicit in the source file
	da_inheritable	BITFIELD MASK;		{ the declaration is inheritable
						{ by another compilation-unit
						{ (only BLISS, PASCAL, and Ada)
	da_is_separate	BITFIELD MASK;		{ The declaration is a stub.
						{ Represents the Ada SEPARATE
						{ attribute.  Ada-only.

	da_spares     BITFIELD LENGTH 8-^ FILL; { reserved for future use
						{  must be zero
	END decl_attri;

{++
{   $ANA_BLISS_DECL_CLASS - ANA BLISS Declaration Class Field
{
{   The ANA Declaration Class Field provides more information about
{   BLISS-specific declaraitons.  In particular, the field makes it
{   possible for SCA to distinguish between LOCAL, STACKLOCAL, REGISTER,
{   GLOBAL REGISTER, and EXTERNAL REGISTER declarations.
{--
    AGGREGATE bliss_decl_class STRUCTURE TAG $ana PREFIX ana$;
	bdc_bliss_decl_class BYTE UNSIGNED;

	CONSTANT min_bliss_decl_class EQUALS 1 PREFIX ana$;

	CONSTANT (  bdc_local,
		    bdc_stacklocal,
		    bdc_register,
		    bdc_global_register,
		    bdc_external_register )
	    EQUALS ana$k_min_bliss_decl_class
		INCREMENT 1 PREFIX ana$ COUNTER #temp;
	    CONSTANT max_bliss_decl_class EQUALS #temp PREFIX ana$;

	END bliss_decl_class;

{++
{   $ANA_ROUTINE_ATTRI - ANA Routine Attribute Field
{
{   The ANA Routine Attribute Field defines a routine attribute.
{
{   These attributes are those that are specific to routines.
{--
    AGGREGATE routine_attri STRUCTURE TAG $ana PREFIX ana$;
	ra_main		BITFIELD MASK;		{ routine is a "main routine"
	ra_noprototype	BITFIELD MASK;		{ the parameter list is not
						{  specified in this declaration
						{  list of formal parameters
	ra_entry_point	BITFIELD MASK;		{ routine is actually an
						{  entry-point
	
	ra_spares  BITFIELD LENGTH 8-^ FILL;    { reserved for future use
						{  must be zero
	END routine_attri;


{++
{   $ANA_CALL_CLASS - ANA Call Class Field
{
{   The ANA Call Class Field defines the kind of calling mechanism associated
{   with a routine.  This field is used both in the declaration node of a 
{   routine and in the call node.
{--
    AGGREGATE call_class STRUCTURE TAG $ana PREFIX ana$;

	CONSTANT min_call_class EQUALS 1 PREFIX ana$;
	CONSTANT (  cc_callg,
		    cc_calls,
		    cc_jsb,
		    cc_inline )
	    EQUALS ana$k_min_call_class INCREMENT 1 PREFIX ana$ COUNTER #temp;
	CONSTANT max_call_class EQUALS #temp PREFIX ana$;

	cc_call_class BITFIELD LENGTH 3;

	cc_cannot_find_ref BITFIELD;		{ set if compiler is not sure if
						{ the called-routine-reference
						{ has its ref-class set to call

	cc_spares     BITFIELD LENGTH 8-^ FILL; { reserved for future use
						{  must be zero
	END call_class;

{++
{   $ANA_PARAMETER_ATTRI - ANA Parameter Attribute Field
{
{   The ANA Parameter Attribute Field defines a passing mechanism,
{   passing mode, and other parameter attributes.
{--
    AGGREGATE parameter_attri STRUCTURE TAG $ana PREFIX ana$;
	pa_mechanism	BITFIELD LENGTH 2;	{ passing mechanism
	    CONSTANT min_mechanism EQUALS 1 PREFIX ana$;
	    CONSTANT (  mechanism_value,
			mechanism_reference,
			mechanism_descriptor )
	       EQUALS ana$k_min_mechanism INCREMENT 1 PREFIX ana$ COUNTER #temp;
	    CONSTANT max_mechanism EQUALS #temp PREFIX ana$;

	pa_spare	BITFIELD MASK FILL;	{ reserved for future use
						{  must be zero

	pa_mode_in	BITFIELD MASK;		{ input parameter
	pa_mode_out	BITFIELD MASK;		{ output parameter

	{ This bit indicates that the parameter is optional and need not
	{ be specified.  This bit must be set on every parameter that is
	{ optional, not just on the first optional parameter as is the case
	{ with BASIC's 'OPTIONAL' keyword.
	{
	pa_optional	BITFIELD MASK;
	
	{ This bit indicates that the parameter list may be truncated at
	{ this parameter.
	{
	pa_truncate	BITFIELD MASK;
	
	{ This bit indicates that zero, one, or more than one parameters
	{ like this one may be supplied in the call.
	{
	pa_list		BITFIELD MASK;
	END parameter_attri;


{++
{   $ANA_TYPE_ATTRI - ANA Type Attribute Field
{
{   The ANA Type Attribute Field defines type attributes.
{
{   At this time, the type attribute field contains Ada-specific attributes.
{--
    AGGREGATE type_attri STRUCTURE TAG $ana PREFIX ana$;
	ta_private	BITFIELD MASK;		{ PRIVATE type
	ta_limited	BITFIELD MASK;		{ LIMITED type
	ta_spares     BITFIELD LENGTH 8-^ FILL; { reserved for future use
						{  must be zero
	END type_attri;

{++
{   $ANA_OBJECT_ATTRI - ANA Object Attribute Field
{
{   The ANA Object Attribute Field defines a object attribute.
{
{   The term "object" is taken from Ada.  Here, it means any program entity
{   that potentially has a execution-time existence.  It includes variables,
{   routines, and tasks.  These attributes are those that are specific 
{   to objects. 
{--
    AGGREGATE object_attri STRUCTURE TAG $ana PREFIX ana$;
	oa_volatile	BITFIELD MASK;		{ object is volatile
	oa_readonly	BITFIELD MASK;		{ object is read-only
	oa_writeonly	BITFIELD MASK;		{ object is write-only

	oa_suppress	BITFIELD MASK;		{ Type checking suppressed
						{  for this object.  This is
						{  the PASCAL UNSAFE attribute.

	{ This field indicates that association of this declaration with
	{ other declarations is done on the basis of similar "global" names.
	{ In other words, when this bit is set SCA will mimic the way the
	{ linker treats objects for which it has global symbol definitions.
	{
	oa_global	BITFIELD MASK;

	{ This field should only be set if the 'global' field is set. 'Weak'
	{ indicates that a weak global symbol definition or reference was 
	{ put out for this symbol.
	{
	oa_weak		BITFIELD MASK;

	{ This field indicates that the size of the array is determined by
	{ the caller.
	{
	oa_conformant	BITFIELD MASK;

	oa_spare	BITFIELD MASK FILL;	{ reserved for future use
						{  must be zero
	END object_attri;

{++
{   $ANA_STORAGE_CLASS - ANA Storage Class Field
{
{   The ANA Storage Class Field is used to indicate where an item lives:
{   'static' means that it is image-permanent, 'automatic' means that the
{   item becomes accessible when a routine is entered and inaccessible 
{   when the routine is left.
{
{   As of this writing 'based', 'controlled', and 'defined' are considered
{   PLI-specific storage-classes.
{--
    AGGREGATE storage_class STRUCTURE TAG $ana PREFIX ana$;
	sc_storage_class BYTE UNSIGNED;

	CONSTANT min_storage_class EQUALS 1 PREFIX ana$;
	CONSTANT (  sc_static,
		    sc_automatic,
		    sc_based,
		    sc_controlled,
		    sc_defined )
	    EQUALS ana$k_min_storage_class 
		INCREMENT 1 PREFIX ana$ COUNTER #temp;
	    CONSTANT max_storage_class EQUALS #temp PREFIX ana$;
	END storage_class;

{++
{   $ANA_MACH_DATA_TYPE - ANA Machine Data Type Field
{
{   The ANA Machine Data Type Field is used to specify the underlying
{   machine representation that results from a language-specific object
{   and type.
{
{   The machine representations are indicated using the "VAX Standard Data
{   Types".
{--
    AGGREGATE mach_data_type  STRUCTURE TAG $ana PREFIX ana$;
	machdtype_code	BYTE UNSIGNED;
	END mach_data_type;

    {	VAX STANDARD TYPE CODES
    {
    { All VAX Standard Type Codes are listed here for convenience.  They are
    { commented out since they are actually declared in STARLET.REQ.
    {
    {   dsc$k_dtype_z	= 0,	! Unspecified
    {   dsc$k_dtype_v	= 1,	! Bit
    {   dsc$k_dtype_bu	= 2,	! Byte logical
    {   dsc$k_dtype_wu	= 3,	! Word logical
    {   dsc$k_dtype_lu	= 4,	! Longword logical
    {   dsc$k_dtype_qu	= 5,	! Quadword logical
    {   dsc$k_dtype_b	= 6,	! Byte integer
    {   dsc$k_dtype_w	= 7,	! Word integer
    {   dsc$k_dtype_l	= 8,	! Longword integer
    {   dsc$k_dtype_q	= 9,	! Quadword integer
    {   dsc$k_dtype_f	= 10,	! Single-precision floating
    {   dsc$k_dtype_d	= 11,	! Double-precision floating
    {   dsc$k_dtype_fc	= 12,	! Complex
    {   dsc$k_dtype_dc	= 13,	! Double-precision Complex
    {   dsc$k_dtype_t	= 14,	! ASCII text string
    {   dsc$k_dtype_nu	= 15,	! Numeric string, unsigned
    {   dsc$k_dtype_nl	= 16,	! Numeric string, left separate sign
    {   dsc$k_dtype_nlo	= 17,	! Numeric string, left overpunched sign
    {   dsc$k_dtype_nr	= 18,	! Numeric string, right separate sign
    {   dsc$k_dtype_nro	= 19,	! Numeric string, right overpunched sign
    {   dsc$k_dtype_nz	= 20,	! Numeric string, zoned sign
    {   dsc$k_dtype_p	= 21,	! Packed decimal string
    {   dsc$k_dtype_zi	= 22,	! Sequence of instructions
    {   dsc$k_dtype_zem	= 23,	! Procedure entry mask
    {   dsc$k_dtype_dsc = 24,	! Descriptor, used for arrays of
    {				!      dynamic strings
    {   dsc$k_dtype_ou	= 25,	! Octaword logical
    {   dsc$k_dtype_o	= 26,	! Octaword integer
    {   dsc$k_dtype_g	= 27,	! Double precision G floating, 64 bit
    {   dsc$k_dtype_h	= 28,	! Quadruple precision floating, 128 bit
    {   dsc$k_dtype_gc	= 29,	! Double precision complex, G floating
    {   dsc$k_dtype_hc	= 30,	! Quadruple precision complex, H floating
    {   dsc$k_dtype_cit	= 31, 	! COBOL intermediate temporary
    {   dsc$k_dtype_bpv	= 32,	! Bound Procedure Value
    {   dsc$k_dtype_blv	= 33,	! Bound Label Value
    {   dsc$k_dtype_vu	= 34,	! Bit Unaligned
    {   dsc$k_dtype_adt	= 35,	! Absolute Date-Time
    {   		= 36,	! Unused (not supported by DEBUG)
    {   dsc$k_dtype_vt  = 37,   ! Varying Text

{++
{   $ANA_PLI_TYPE - ANA PLI Specific Type Field
{
{   The ANA PLI Specific Type Field defines PLI-specific type information.
{--
    AGGREGATE pli_type STRUCTURE TAG $ana PREFIX ana$;
	plit_file	BITFIELD;
	plit_entry	BITFIELD;
	plit_label	BITFIELD;
	plit_character  BITFIELD;
	plit_bit	BITFIELD;
	plit_picture	BITFIELD;
	plit_fixed	BITFIELD;
	plit_float	BITFIELD;
	plit_area	BITFIELD;
	plit_binary	BITFIELD;
	plit_decimal    BITFIELD;
	plit_varying	BITFIELD;
	plit_spares  BITFIELD LENGTH 16-^ FILL; { reserved for future use
						{  must be zero
	END;

{++
{   $ANA_PSECT_ATTRI_W - ANA Psect Attribute Field
{
{   The ANA Psect Attribute Field defines psect attribute information.
{   This field is only appropriate for declarations of psects.
{--
    AGGREGATE psect_attri_w STRUCTURE TAG $ana PREFIX ana$;

	{ If the PSECT is relocatable, virtual memory will be
	{ allocated and the linker will place the PSECT accordingly.
	{ The linker allocates no memory for an absolute PSECT.  It
	{ may contain no data or code and is used mainly to define
	{ global symbols.
	{
	psa_rel_not_abs BITFIELD MASK;

	{ PSECTs of the same name from more than one module will be
	{ overlaid if the OVR attribute is specified.  If the CON
	{ attribute is used the contributions to this PSECT from
	{ different modules are concatenated, handling alignment
	{ according to the needs of the PSECT as specified in each
	{ module.
	{
	psa_ovr_not_con BITFIELD MASK;

	{ PSECTs of the same name in modules in separate clusters,
	{ if specified with the GBL attribute, will be placed in the
	{ same cluster.  Otherwise, they are kept in separate clusters.
	{
	psa_lcl_not_gbl BITFIELD MASK;

	{ The PSECT contains executable code or not.
	{
	psa_exe_not_noexe BITFIELD MASK;

	{ The PSECT may be modified or not.
	{
	psa_wrt_not_nowrt BITFIELD MASK;

	{ Reserved for future use - must be zero.
	{
	psa_rd_not_nord  BITFIELD MASK;

	{ The PSECT contains position independent code or not.
	{
	psa_pic_not_nopic BITFIELD MASK;

	{ PSECT can (or not) be shared among processes.
	{
	psa_shr_not_noshr BITFIELD MASK;

	{ Reserved for future use: must be zero
	{
	psa_usr_not_nolib BITFIELD MASK;

	{ This PSECT contains (or not) privileged change-mode vectors
	{ or message vectors.
	{
	psa_vec_not_novec BITFIELD MASK;

	psa_spares   BITFIELD LENGTH 16-^ FILL; { reserved for future use
						{  must be zero
	END psect_attri_w;

{++
{   $ANA_NODE_KIND - ANA Node Kind Field
{
{   The ANA Node Kind Field is used in Semantic Node and 
{   Fields Of A Semantic Node Commands to indicate which kind of
{   semantic node it is.
{--
    AGGREGATE node_kind STRUCTURE TAG $ana PREFIX ana$;
	nodekind_node_kind BYTE UNSIGNED;

	{ This list defines the semantic node kinds.  This list 
	{ might grow considerably in later versions of this interface.
	{
	CONSTANT min_node_kind EQUALS 1 PREFIX ana$;

	CONSTANT (  node_declaration,
		    node_reference,
		    node_unbound,
		    node_instantiation,
		    node_scope,
		    node_group,
		    node_call,
		    node_parameter,
		    node_return_value,
		    node_component_selection,
		    node_equivalence,
		    node_comment,
		    node_name_in_comment,
		    node_keyword )
	       EQUALS ana$k_min_node_kind INCREMENT 1 PREFIX ana$ COUNTER #temp;
	    CONSTANT max_node_kind EQUALS #temp PREFIX ana$;
	END node_kind;

{++
{   $ANA_SEM_NODE - ANA Semantic Node Command
{
{   The Semantic Node (SN) Command defines a semantic node.  The specification
{   of the semantic note is accomplished via a list of Field Value Commands 
{   that follow the SN command.  The end of the kind-value list is indicated 
{   by the end-of-node field-kind, which takes a zero-length field-value
{   field.
{
{   An SN Command is sufficient to completely describe a node.  However, 
{   the description of a given node can be spread across a Semantic Node
{   Command, and one or more Fields Of A Semantic Node Command's (FSN's).
{   Each FSN refers to its associated SN.  The SN does not have to provide
{   any information about the node (though I can't imagine why a language
{   processor would want to do this).
{--
    AGGREGATE sem_node STRUCTURE TAG $ana PREFIX ana$;
	sn_cmdkind	BYTE UNSIGNED;		{ command kind
	END sem_node;

{++
{   $ANA_FIELD_KIND_VALUE - ANA Field Kind Value Sub-command
{
{   The Field Kind Value (FKV) Sub-command is used to specify a field of a 
{   semantic node.  
{
{   The Field Kind Value Sub-command is a "sub-"command in that it is used 
{   exclusively in conjunction with the SN command, and in that it does
{   have a command-kind.
{
{   The Field Kind Value Sub-command is identical to a part of the Fields of a 
{   Semantic Node Command, and uses the literals specified in the 
{   definition of the FSN command.
{--
    AGGREGATE field_kind_value STRUCTURE TAG $ana PREFIX ana$;
	fkv_field_kind	BYTE UNSIGNED;		{ field value field kind

	CONSTANT fkv_fixed_part_size EQUALS .;

	fkv_base CHARACTER LENGTH 0 TAG z;{ beginning of field value

	fkv_sizes UNION;
		CONSTANT fkv_null_size EQUALS .;
	    fkv_byte BYTE UNSIGNED;
		CONSTANT fkv_byte_size EQUALS .;
	    fkv_word WORD UNSIGNED;
		CONSTANT fkv_word_size EQUALS .;
	    fkv_long LONGWORD UNSIGNED; 
		CONSTANT fkv_long_size EQUALS .;
	    fkv_quad QUADWORD UNSIGNED; 
		CONSTANT fkv_quad_size EQUALS .;
	    END fkv_sizes;

	CONSTANT min_size EQUALS 0 PREFIX ana$;
	CONSTANT null_size EQUALS 0 PREFIX ana$;
	CONSTANT byte_size EQUALS 1 PREFIX ana$;
	CONSTANT word_size EQUALS 2 PREFIX ana$;
	CONSTANT long_size EQUALS 4 PREFIX ana$;
	CONSTANT quad_size EQUALS 8 PREFIX ana$;
	CONSTANT max_size EQUALS 8 PREFIX ana$;

	END field_kind_value;

{++
{	FIELDS OF A SEMANTIC NODE COMMANDS
{
{   The Fields Of A Semantic Node Commands provide information about a 
{   semantic nodes.
{--

{++
{   $ANA_FIELDS_SEM_NODE_W - ANA Fields Of A Semantic Node Word Command
{
{   The Fields Of A Semantic Node Word Command provides information about a 
{   semantic node, using a word-sized pointer to the corresponding Semantic
{   Node Command.
{--
    AGGREGATE fields_sem_node_w STRUCTURE TAG $ana PREFIX ana$;
	fsnw_cmdkind	BYTE UNSIGNED;		{ command kind

	fsnw_sn		WORD UNSIGNED;		{ ptr to Semantic Node Command
	END fields_sem_node_w;


{++
{   $ANA_FIELDS_SEM_NODE_L - ANA Fields Of A Semantic Node Long Command
{
{   The Fields Of A Semantic Node Long Command provides information about a 
{   semantic node, using a longword-sized pointer to the corresponding 
{   Semantic Node Command.
{--
    AGGREGATE fields_sem_node_l STRUCTURE TAG $ana PREFIX ana$;
	fsnl_cmdkind	BYTE UNSIGNED;		{ command kind

	fsnl_sn		LONGWORD UNSIGNED;	{ ptr to Semantic Node Command
	END fields_sem_node_l;

{++
{	FIELD KINDS / FIELD SIZES
{
{ Here, the field-kinds are defined.  These field-kinds are primarily
{ explained in two places: in the definition of the various kinds of
{ classes and attributes at the beginning of the semantic information
{ section of this data file spec, and in the design note  
{ "How SCA Views Source Code", especially via the syntax summary.
{
{ Every field-kind, except for the first one, takes a field-value 
{ whose size (byte, word, longword, or quadword) is indicated by the 
{ field-kind.  The last single letter following an underscore of the
{ field-kind name indicates the size of its field.  The sizes of the
{ fields are defined in the list of definitions that follows the list
{ of field-kind definitions.  The absense of a single letter following
{ an underscore indicates that a field-kind has no field-value (or that
{ the size of its field-value is zero bytes).
{--
    CONSTANT min_field_kind EQUALS 1 PREFIX ana$;
    CONSTANT max_field_kind EQUALS 255 PREFIX ana$;

    CONSTANT (  
	{ The following list of field-kinds are pointers to
	{ event stream entries.  They all point to either
	{ Lex-Loc commands (the first 12 kinds), or to SN
	{ commands (all the other kinds).  As is done throughout 
	{ the data file spec, pointers to events come in two sizes:
	{ word and longword.  The assumption is that the word-sized
	{ field will almost always be large enough.
	{
	{ Pointer-fields come in two sizes: word-sized and longword-sized
	{ fields.   A longword-sized pointer-field-kind code is always one
	{ greater than its corresponding word-sized pointer-field-kind code.
	{ Furthermore, word-sized pointer-field-kind codes are odd, and  
	{ longword-sized pointer-field-kind codes are even.
	{
	{ Each field is a pointer to a:
	{ 
	kind_name_lexloc_w,	{ name lexical-location, not hidden
	kind_name_lexloc_l,
	kind_gname_lexloc_w,	{ global name lex-loc, not hidden
    	kind_gname_lexloc_l,
	kind_hid_name_lexloc_w,	{ name lexical-location, hidden
	kind_hid_name_lexloc_l,
	kind_hid_gname_lexloc_w,{ global name lex-loc, hidden
	kind_hid_gname_lexloc_l,
	kind_beg_lexloc_w,	{ lex-loc of beginning of lexical
	kind_beg_lexloc_l,	{  range of semantic node
	kind_end_lexloc_w,	{ lex-loc of end of lexical
	kind_end_lexloc_l,	{  range of semantic node

	kind_do_not_use_me_1_w,	{ these field-kind codes are
	kind_do_not_use_me_1_l,	{ reserved for future use
	kind_do_not_use_me_2_w,	{ 
	kind_do_not_use_me_2_l,	{ do not use them
	kind_do_not_use_me_3_w,
	kind_do_not_use_me_3_l,
	kind_do_not_use_me_4_w,
	kind_do_not_use_me_4_l,

	kind_assoc_decl_w,	{ associated declaration
	kind_assoc_decl_l,
	kind_derivation_of_w,	{ (Ada) pointer from declaration to
	kind_derivation_of_l,	{  reference of that which is being derived
	kind_instantiation_of_w,{ (Ada) pointer from declaration to
	kind_instantiation_of_l,{  instantiation-node for generic-instantiation
	kind_with_ref_w,	{ WITH reference (Ada-specific)
	kind_with_ref_l,
	kind_use_ref_w,		{ USE reference (Ada-specific)
	kind_use_ref_l,
	kind_separate_ref_w,	{ SEPARATE reference (Ada-specific)
	kind_separate_ref_l,
	kind_gen_spec_w,	{ (Ada-specific) pointer from generic-decl to
	kind_gen_spec_l,	{  corresponding subprogram- or package-spec
 	kind_like_ref_w,	{ LIKE reference (PLI-specific)
	kind_like_ref_l,
	kind_refer_ref_w,	{ REFER reference (PLI-specific)
	kind_refer_ref_l,
	kind_based_ref_w,	{ BASED reference (PLI-specific)
	kind_based_ref_l,
	kind_defined_ref_w,	{ DEFINED reference (PLI-specific)
	kind_defined_ref_l,
	kind_linkage_ref_w,	{ LINKAGE reference (BLISS-specific)
	kind_linkage_ref_l,
	kind_field_ref_w,	{ FIELD field reference (BLISS-specific)
	kind_field_ref_l,
	kind_structure_ref_w,	{ STRUCTURE reference (BLISS-specific)
	kind_structure_ref_l,
	kind_type_w,		{ type declaration or a
	kind_type_l,		{  type reference
	kind_psect_decl_w,	{ PSECT declaration from an
	kind_psect_decl_l,	{  object declaration node
	kind_decl_w,		{ declaration node from a 
	kind_decl_l,		{  reference node
	kind_formal_w,		{ formal parameter reference, used
	kind_formal_l,		{  for parameter nodes
	kind_parameter_w,	{ parameter expression, used for call,
	kind_parameter_l,	{  component-selection, replacement nodes
	kind_renames_w,		{ pointer from variable/routine declaration
	kind_renames_l,		{  to renames expression (Ada, BLISS,...)
	kind_prefix_w,		{ expression describing what is called by a
	kind_prefix_l,		{  call or selected by a component-selection
	kind_equivalence_w,	{ a child expression of an
	kind_equivalence_l,	{  equivalence node
	kind_input_file_w,	{ pointer to an Input File Command from a
	kind_input_file_l,	{  module declaration-SN
	kind_module_w,		{ pointer to module declaration-SN from
	kind_module_l,		{  a decl-SN of a loading from pre-compilation
	kind_parent_w,		{ pointer from child- to parent-node (used by
	kind_parent_l,		{  PASCAL for inherited record-components)
	kind_comment_w,		{ (PDL) pointer from declaration-node to 
	kind_comment_l,		{  associated comment-node
	kind_text_w,		{ (PDL) pointer from comment-node to 
	kind_text_l		{  associated text-command
	  )   EQUALS ana$k_min_field_kind INCREMENT 1 PREFIX ana$ COUNTER #temp;
	    CONSTANT max_pointer_kind EQUALS #temp PREFIX ana$;

    CONSTANT min_pointer_kind EQUALS ana$k_min_field_kind PREFIX ana$;

    CONSTANT min_nonpointer_kind EQUALS 177 PREFIX ana$;


	{ This is the end of the pointer fields and beginning of the
	{ non-pointer fields.  Many of these fields are described in the
	{ section about classes and attributes at the beginning of the
	{ larger section describing semantic information in this data file
	{ spec.  The structure names of the class and attribute definitions
	{ are given in the right-most column.  Some of these fields have an
	{ interesting data structure, some are enumerated-lists, others are
	{ simply unsigned-integers.
	{
    CONSTANT(
	{ This first field-kind is used to indicate the end 
	{ of a list of kind-value pairs.
	{
	kind_end_of_command,
	kind_ref_class_repl_b,	{ reference class (replaceable)	- $ANA_REF_CLASS
	kind_ref_class_norepl_b,{ reference class (non-replaceable)
	kind_decl_class_b,	{ declaration class	- $ANA_DECL_CLASS
	kind_decl_attri_b,	{ declaration attributes- $ANA_DECL_ATTRI
	kind_bliss_decl_class_b,{ BLISS-specific	- $ANA_BLISS_DECL_CLASS
	kind_rout_attri_b,      { routine attributes	- $ANA_ROUTINE_ATTRI
	kind_call_class_b,	{ call class		- $ANA_CALL_CLASS
	kind_param_attri_b,	{ eg. passing mechanism - $ANA_PARAMETER_ATTRI
	kind_type_attri_b,	{ type attributes	- $ANA_TYPE_ATTRI
	kind_object_attri_b,    { object attributes	- $ANA_OBJECT_ATTRI 
	kind_storage_class_b,	{ storage-class		- $ANA_STORAGE_CLASS
	kind_mach_dtype_b,	{ VAX Data Types	- $ANA_MACH_DATA_TYPE
	kind_mach_dsize_w,	{ machine size when the machine-data-type
	kind_mach_dsize_l,	{  does not indicate the size
	kind_node_kind_b,	{ semantic node kind	- $ANA_NODE_KIND
	kind_pli_type_w,	{ PLI-specific type info- $ANA_PLI_TYPE
	kind_psect_attri_w,	{ psect attributes      - $ANA_PSECT_ATTRI_W
	kind_psect_offset_w,    { offset from beginning 
	kind_psect_offset_l,    {  of psect (in bytes)
	kind_precision_b,	{ precision
	kind_scale_factor_b,	{ scale factor 
	kind_register_num_b,    { parameter register number 
	kind_stack_offset_w,    { parameter offset from
	kind_stack_offset_l,    {  stack frame in bytes
	kind_timestamp_q,	{ compilation date-time, VMS binary format
	kind_gst_w,		{ index into 
	kind_gst_l,		{  Ada Global Symbol Table
	kind_name_w,		{ name-id of the name
	kind_name_l,		{  of a declaration
	kind_global_name_w,	{ name-id of the global-name of a declaration,
	kind_global_name_l )    {  only if different from the local-name
		EQUALS ana$k_min_nonpointer_kind 
		    INCREMENT 1 PREFIX ana$ COUNTER #temp;
	    CONSTANT max_nonpointer_kind EQUALS #temp PREFIX ana$;

	{ Here, the field sizes (in bytes) are defined.
	{
	CONSTANT size_name_lexloc_w EQUALS 2 PREFIX ana$;
	CONSTANT size_name_lexloc_l EQUALS 4 PREFIX ana$;
	CONSTANT size_gname_lexloc_w EQUALS 2 PREFIX ana$;
	CONSTANT size_gname_lexloc_l EQUALS 4 PREFIX ana$;
	CONSTANT size_hid_name_lexloc_w EQUALS 2 PREFIX ana$;
	CONSTANT size_hid_name_lexloc_l EQUALS 4 PREFIX ana$;	
	CONSTANT size_hid_gname_lexloc_w EQUALS 2 PREFIX ana$;
	CONSTANT size_hid_gname_lexloc_l EQUALS 4 PREFIX ana$;
	CONSTANT size_beg_lexloc_w EQUALS 2 PREFIX ana$;
	CONSTANT size_beg_lexloc_l EQUALS 4 PREFIX ana$;
	CONSTANT size_end_lexloc_w EQUALS 2 PREFIX ana$;
	CONSTANT size_end_lexloc_l EQUALS 4 PREFIX ana$;

	CONSTANT size_do_not_use_me_1_w EQUALS 2 PREFIX ana$;
	CONSTANT size_do_not_use_me_1_l EQUALS 2 PREFIX ana$;
	CONSTANT size_do_not_use_me_2_w EQUALS 2 PREFIX ana$;
	CONSTANT size_do_not_use_me_2_l EQUALS 2 PREFIX ana$;
	CONSTANT size_do_not_use_me_3_w EQUALS 2 PREFIX ana$;
	CONSTANT size_do_not_use_me_3_l EQUALS 2 PREFIX ana$;
	CONSTANT size_do_not_use_me_4_w EQUALS 2 PREFIX ana$;
	CONSTANT size_do_not_use_me_4_l EQUALS 2 PREFIX ana$;

	CONSTANT size_assoc_decl_w EQUALS 2 PREFIX ana$;
	CONSTANT size_assoc_decl_l EQUALS 4 PREFIX ana$;
	CONSTANT size_derivation_of_w EQUALS 2 PREFIX ana$;
	CONSTANT size_derivation_of_l EQUALS 4 PREFIX ana$;
	CONSTANT size_instantiation_of_w EQUALS 2 PREFIX ana$;
	CONSTANT size_instantiation_of_l EQUALS 4 PREFIX ana$;
	CONSTANT size_with_ref_w EQUALS 2 PREFIX ana$;
	CONSTANT size_with_ref_l EQUALS 4 PREFIX ana$;
	CONSTANT size_use_ref_w EQUALS 2 PREFIX ana$;
	CONSTANT size_use_ref_l EQUALS 4 PREFIX ana$;
	CONSTANT size_separate_ref_w EQUALS 2 PREFIX ana$;
	CONSTANT size_separate_ref_l EQUALS 4 PREFIX ana$;
	CONSTANT size_gen_spec_w EQUALS 2 PREFIX ana$;
	CONSTANT size_gen_spec_l EQUALS 4 PREFIX ana$;
	CONSTANT size_like_ref_w EQUALS 2 PREFIX ana$;
	CONSTANT size_like_ref_l EQUALS 4 PREFIX ana$;
	CONSTANT size_refer_ref_w EQUALS 2 PREFIX ana$;
	CONSTANT size_refer_ref_l EQUALS 4 PREFIX ana$;
	CONSTANT size_based_ref_w EQUALS 2 PREFIX ana$;
	CONSTANT size_based_ref_l EQUALS 4 PREFIX ana$;
	CONSTANT size_defined_ref_w EQUALS 2 PREFIX ana$;
	CONSTANT size_defined_ref_l EQUALS 4 PREFIX ana$;
	CONSTANT size_linkage_ref_w EQUALS 2 PREFIX ana$;
	CONSTANT size_linkage_ref_l EQUALS 4 PREFIX ana$;
	CONSTANT size_field_ref_w EQUALS 2 PREFIX ana$;
	CONSTANT size_field_ref_l EQUALS 4 PREFIX ana$;
	CONSTANT size_structure_ref_w EQUALS 2 PREFIX ana$;
	CONSTANT size_structure_ref_l EQUALS 4 PREFIX ana$;
	CONSTANT size_type_w EQUALS 2 PREFIX ana$;
	CONSTANT size_type_l EQUALS 4 PREFIX ana$;
	CONSTANT size_psect_decl_w EQUALS 2 PREFIX ana$;
	CONSTANT size_psect_decl_l EQUALS 4 PREFIX ana$;
	CONSTANT size_decl_w EQUALS 2 PREFIX ana$;
	CONSTANT size_decl_l EQUALS 4 PREFIX ana$;
	CONSTANT size_formal_w EQUALS 2 PREFIX ana$;
	CONSTANT size_formal_l EQUALS 4 PREFIX ana$;
	CONSTANT size_parameter_w EQUALS 2 PREFIX ana$;
	CONSTANT size_parameter_l EQUALS 4 PREFIX ana$;
	CONSTANT size_renames_w EQUALS 2 PREFIX ana$;
	CONSTANT size_renames_l EQUALS 4 PREFIX ana$;
	CONSTANT size_prefix_w EQUALS 2 PREFIX ana$;
	CONSTANT size_prefix_l EQUALS 4 PREFIX ana$;
	CONSTANT size_equivalence_w EQUALS 2 PREFIX ana$;
	CONSTANT size_equivalence_l EQUALS 4 PREFIX ana$;
	CONSTANT size_input_file_w EQUALS 2 PREFIX ana$;
	CONSTANT size_input_file_l EQUALS 4 PREFIX ana$;
	CONSTANT size_module_w EQUALS 2 PREFIX ana$;
	CONSTANT size_module_l EQUALS 4 PREFIX ana$;
	CONSTANT size_parent_w EQUALS 2 PREFIX ana$;
	CONSTANT size_parent_l EQUALS 4 PREFIX ana$;
	CONSTANT size_comment_w EQUALS 2 PREFIX ana$;
	CONSTANT size_comment_l EQUALS 4 PREFIX ana$;
	CONSTANT size_text_w EQUALS 2 PREFIX ana$;
	CONSTANT size_text_l EQUALS 4 PREFIX ana$;

	CONSTANT size_end_of_command EQUALS 0 PREFIX ana$;
	CONSTANT size_ref_class_repl_b EQUALS 1 PREFIX ana$;
	CONSTANT size_ref_class_norepl_b EQUALS 1 PREFIX ana$;
	CONSTANT size_decl_class_b EQUALS 1 PREFIX ana$;
	CONSTANT size_decl_attri_b EQUALS 1 PREFIX ana$;
	CONSTANT size_bliss_decl_class_b EQUALS 1 PREFIX ana$;
	CONSTANT size_rout_attri_b EQUALS 1 PREFIX ana$;
	CONSTANT size_call_class_b EQUALS 1 PREFIX ana$;
	CONSTANT size_param_attri_b EQUALS 1 PREFIX ana$;
	CONSTANT size_type_attri_b EQUALS 1 PREFIX ana$;
	CONSTANT size_object_attri_b EQUALS 1 PREFIX ana$;
	CONSTANT size_storage_class_b EQUALS 1 PREFIX ana$;
	CONSTANT size_mach_dtype_b EQUALS 1 PREFIX ana$;
	CONSTANT size_mach_dsize_w EQUALS 2 PREFIX ana$;
	CONSTANT size_mach_dsize_l EQUALS 4 PREFIX ana$;
	CONSTANT size_node_kind_b EQUALS 1 PREFIX ana$;
	CONSTANT size_pli_type_w EQUALS 2 PREFIX ana$;
	CONSTANT size_psect_attri_w EQUALS 2 PREFIX ana$;
	CONSTANT size_psect_offset_w EQUALS 2 PREFIX ana$;
	CONSTANT size_psect_offset_l EQUALS 4 PREFIX ana$;
	CONSTANT size_precision_b EQUALS 1 PREFIX ana$;
	CONSTANT size_scale_factor_b EQUALS 1 PREFIX ana$;
	CONSTANT size_register_num_b EQUALS 1 PREFIX ana$;
	CONSTANT size_stack_offset_w EQUALS 2 PREFIX ana$;
	CONSTANT size_stack_offset_l EQUALS 4 PREFIX ana$;
	CONSTANT size_timestamp_q EQUALS 8 PREFIX ana$;
	CONSTANT size_gst_w EQUALS 2 PREFIX ana$;
	CONSTANT size_gst_l EQUALS 4 PREFIX ana$;
	CONSTANT size_name_w EQUALS 2 PREFIX ana$;
	CONSTANT size_name_l EQUALS 4 PREFIX ana$;
	CONSTANT size_global_name_w EQUALS 2 PREFIX ana$;
	CONSTANT size_global_name_l EQUALS 4 PREFIX ana$;

END_MODULE analysis_data;
