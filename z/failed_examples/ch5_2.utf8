\chapter{\Betw\ model, promoted world}\label{ch5}

‚îÄ section ch5 parents ch4 ‚îî 

\section{The world}

\begin{LConsistency}[$Logbook$ consistency]
\begin{zeves-theorem}{tLogbookConsistency}
    \exists Logbook: \power~(NAMES \rel PayDetails) @ \\
        \t1 Logbook = \power~(\{~PayDetails @ from \mapsto \theta PayDetails~\} \cup \\
             \t2 \{~PayDetails @ to \mapsto \theta PayDetails ~\})
\end{theorem}~\end{LConsistency}

\begin{LADef}[Log book of payments]
‚ï∑ Logbook : ‚Ñô ( NAMES ‚Üî PayDetails ) |
 Logbook = ‚Ñô ( { PayDetails ‚¶Å from ‚Ü¶ Œ∏ PayDetails } ‚à™ { PayDetails ‚¶Å to ‚Ü¶ Œ∏ PayDetails } ) ‚îî ~\end{LADef}
\begin{LSDef}[Concrete world]
‚îå ConWorld 
conAuthPurse : NAMES ‚§ï ConPurse 
ether : ‚Ñô MESSAGE 
archive : Logbook |
 ‚àÄ n : dom conAuthPurse ‚¶Å ( conAuthPurse n ) . name = n 
‚àÄ nld : archive ‚¶Å first nld ‚àà dom conAuthPurse ‚îî ~\end{LSDef}


\section{Auxiliary definitions}\label{ch5.auxworld}

Now, we leave the definition of $AuxWorld$ without mentioning
any finiteness properties, but prove it later as a consequence of
the involved sets being restricted to the domain of the finite injection $conAuthPurse$
from $ConWorld$.
\begin{LSDef}[Auxiliary definitions for the concrete world]
‚îå AuxWorld 
ConWorld 
allLogs : NAMES ‚Üî PayDetails 
authenticFrom , authenticTo : ‚Ñô PayDetails 
fromLogged , toLogged : ‚Ñô PayDetails 
toInEpv , toInEapayee , fromInEpr , fromInEpa : ‚Ñô PayDetails 
definitelyLost : ‚Ñô PayDetails 
maybeLost : ‚Ñô PayDetails |
 toInEpv ‚àà ùîΩ PayDetails 
toInEapayee ‚àà ùîΩ PayDetails 
fromInEpr ‚àà ùîΩ PayDetails 
fromInEpa ‚àà ùîΩ PayDetails 
maybeLost ‚àà ùîΩ PayDetails 
fromLogged = { pd : authenticFrom | pd . from ‚Ü¶ pd ‚àà allLogs } 
toLogged = { pd : authenticTo | pd . to ‚Ü¶ pd ‚àà allLogs } 
authenticFrom = { pd : PayDetails | pd . from ‚àà dom conAuthPurse } 
authenticTo = { pd : PayDetails | pd . to ‚àà dom conAuthPurse } 
toInEpv = { pd : authenticTo | ( conAuthPurse pd . to ) . status = epv ‚àß ( conAuthPurse pd . to ) . pdAuth = pd } 
toInEapayee = { pd : authenticTo | ( conAuthPurse pd . to ) . status = eaTo ‚àß ( conAuthPurse pd . to ) . pdAuth = pd } 
fromInEpr = { pd : authenticFrom | ( conAuthPurse pd . from ) . status = epr ‚àß ( conAuthPurse pd . from ) . pdAuth = pd } 
fromInEpa = { pd : authenticFrom | ( conAuthPurse pd . from ) . status = epa ‚àß ( conAuthPurse pd . from ) . pdAuth = pd } 
allLogs = archive ‚à™ { n : dom conAuthPurse ; pd : PayDetails | pd ‚àà ( conAuthPurse n ) . exLog } 
definitelyLost = toLogged ‚à© ( fromLogged ‚à™ fromInEpa ) 
maybeLost = ( fromInEpa ‚à™ fromLogged ) ‚à© toInEpv ‚îî ~\end{LSDef}
\begin{LThm}[Auxiliary world elements identity]
\begin{zeves-theorem}{tAuxWorldIdentity}
   \forall AuxWorld @ definitelyLost \cup maybeLost = \\
        \t1 (fromInEpa \cup fromLogged) \cap (toInEpv \cup toLogged)
\end{theorem}~\end{LThm}

\subsection{Added information about finiteness}


From the original document, it was left implicit that $authenticFrom$ and $authenticTo$ were finite as well.
Thus, we explicitly prove that both $authenticFrom$ and $authenticTo$ are finite, something missing from
the original definition. Before adding the necessary forward rules, we need some extra lemmas about the
finiteness of particular $PayDetails$ sets.

\subsubsection{Extending the toolkit}

\begin{LToolkit}[Improved version of toolkit rule $crossFinite$]
\begin{zeves-theorem}{rule rCrossFinite}
  A \cross B \in \finset (C \cross D) \iff \\\t1
  A = \{\} \lor B = \{\} \lor (A \in \finset C \land B \in \finset D)
\end{theorem}~\end{LToolkit}

\begin{LToolkit}[Subset of finite set is finite]
\begin{zeves-theorem}{lFinsetSubset}
  X \in \power Y \land Y \in \finset Z \implies X \in \finset Z
\end{theorem}~\end{LToolkit}

\subsubsection{$PayDetails$ bindings are finite}

To prove these lemmas, we need to establish a basic theory for $PayDetais$ finiteness first.
As we have already included finite types in $PayDetails$, it becomes possible to prove a more basic
fact needed for the lemmas mentioned above. That is, the set of bindings $PayDetails$ represent is itself finite
\begin{gzed}
   PayDetails \in \finset \lblot from: NAME; to: NAME; value: \num; fromSeqNo: \num; toSeqNo: \num \rblot
\end{gzed}
To prove this basic lemma, we need to establish some facts about finiteness in general, they are given below.
Firstly, let us define the space under concern as the cross product of $PayDetails$ components
shaped as
\begin{gzed}
((from, to), (value, (fromSeqNo, toSeqNo)))
\end{gzed}
\begin{LNewADef}[Possible values for $PayDetails$ components]
‚îÄ PayDetailsSpace == ( NAMES √ó NAMES ) √ó ( NAT √ó ( NAT √ó NAT ) ) ‚îî ~\end{LNewADef}

\begin{LNewADef}[Possible values for $PayDetails$ bindings]
‚îÄ PayDetailsBindings == { PayDetails ‚¶Å ( ( ( from , to ) , ( value , ( fromSeqNo , toSeqNo ) ) ) , Œ∏ PayDetails ) } ‚îî ~\end{LNewADef}

\begin{LNewLemma}[$PayDetails$ space is finite]
\begin{zeves-theorem}{lPayDetailsSpaceFiniteMaxType}
    PayDetailsSpace \in \finset~((NAME \cross NAME) \cross (\num \cross (\num \cross \num)))
\end{theorem}~\end{LNewLemma}

\begin{LNewLemma}[$PayDetails$ bindings are within $PayDetails$ space]
\begin{zeves-theorem}{lPayDetailsBindingsSubsetPayDetailsSpace}
    \dom~PayDetailsBindings \in \power~PayDetailsSpace
\end{theorem}~\end{LNewLemma}

\begin{LNewLemma}[$PayDetails$ bindings are finite]
\begin{zeves-theorem}{lPayDetailsBindingsFiniteMaxType}
    \dom~PayDetailsBindings \in \finset~((NAME \cross NAME) \cross (\num \cross (\num \cross \num)))
\end{theorem}~\end{LNewLemma}

\begin{LGRT}[$PayDetails$ bindings maximal $\pfun$ type]
\begin{zeves-theorem}{grule gPayDetailsBindingsPfun}
    PayDetailsBindings \in ((NAME \cross NAME) \cross (\num \cross (\num \cross \num))) \pfun PayDetails
\end{theorem}~\end{LGRT}

\begin{LGRT}[$PayDetails$ bindings maximal $\ffun$ type]
\begin{zeves-theorem}{grule gPayDetailsBindingsFfun}
    PayDetailsBindings \in ((NAME \cross NAME) \cross (\num \cross (\num \cross \num))) \ffun PayDetails
\end{theorem}~\end{LGRT}

\begin{LNewLemma}[$PayDetails$ bindings encompass the whole of $PayDetails$]
\begin{zeves-theorem}{rule lPayDetailsBindinsRange}
    \ran~PayDetailsBindings = PayDetails
\end{theorem}~\end{LNewLemma}

\begin{LNewLemma}[$PayDetails$ is a finite set of its bindings]
\begin{zeves-theorem}{grule lPayDetailsIsFinite}
    PayDetails \in \finset~\lblot from: NAME; fromSeqNo: \num; to: NAME; toSeqNo: \num; value: \num \rblot
\end{theorem}~\end{LNewLemma}

\subsubsection{$PayDetails$ sets that we are interested in are finite}

\begin{LNewLemma}[$PayDetails$ fixed $from$ is finite]
\begin{zeves-theorem}{rule lPayDetailsFromPurseNameFinite}
    \forall name: NAMES @ \{~  pd: PayDetails | pd.from = name ~\} \in \finset~PayDetails
\end{theorem}~\end{LNewLemma}

\begin{LNewLemma}[$PayDetails$ fixed $to$ is finite]
\begin{zeves-theorem}{rule lPayDetailsToPurseNameFinite}
    \forall name: NAMES @ \{~  pd: PayDetails | pd.to = name ~\} \in \finset~PayDetails
\end{theorem}~\end{LNewLemma}

\begin{LNewLemma}[$PayDetails$ $from$ purse from $\dom$ is finite]
\begin{zeves-theorem}{rule lPayDetailsFromPurseDomainFinite}
    \forall purse: NAMES \finj ConPurse  @ \\
        \t1 \{~  pd: PayDetails | pd.from \in \dom~purse ~\} \in \finset~PayDetails
\end{theorem}~\end{LNewLemma}

\begin{LNewLemma}[$PayDetails$ $to$ purse from $\dom$ is finite]
\begin{zeves-theorem}{rule lPayDetailsToPurseDomainFinite}
    \forall purse: NAMES \finj ConPurse  @ \\
        \t1 \{~  pd: PayDetails | pd.to \in \dom~purse ~\} \in \finset~PayDetails
\end{theorem}~\end{LNewLemma}


Now, from the definition of $AuxWorld$, the necessary theorems about its components is trivial.
\begin{LFRT}[$AuxWorld$ $authenticFrom$ is finite]
\begin{zeves-theorem}{frule fAuxWorldAuthenticFromIsFinite}
   \forall AuxWorld @ authenticFrom \in \finset~PayDetails
\end{theorem}~\end{LFRT}
\begin{LFRT}[$AuxWorld$ $authenticFrom$ is finite]
\begin{zeves-theorem}{frule fAuxWorldAuthenticToIsFinite}
   \forall AuxWorld @ authenticTo \in \finset~PayDetails
\end{theorem}~\end{LFRT}

\subsection{$AuxWorld$ does not add constraints}

\begin{LSDef}[Concrete world auxiliary definitions relationship]
‚îÄ NewVariables == ‚àÉ ConWorld ‚¶Å AuxWorld ‚îî ~\end{LSDef}

For the next theorem, because of the way finiteness is encoded in Mondex,
we need additional lemmas. Furthermore, because \zeves\ does not accept
using complex expressions (with schema binding selection within set comprehension)
in the middle of a proof, we need to cover these finiteness properties through
axiomatic definitions.

Firstly, we add those payments related to the domain of authentic purses.
\begin{LNewADef}[$PayDetails$ elements for $from$ $purse$]
‚ï∑ PayDetailsFromDomPurse : ‚Ñô PayDetails |
 ‚àÄ purse : NAMES ‚§ï ConPurse ‚¶Å PayDetailsFromDomPurse = { pd : PayDetails | pd . from ‚àà dom purse } ‚îî ~\end{LNewADef}

TODO: Add consistency lambda-terms here! See Z/EVES user's guide p.22 (3.1.3).
\begin{LNewADef}[$PayDetails$ elements for $to$ $purse$]
‚ï∑ PayDetailsToDomPurse : ‚Ñô PayDetails |
 ‚àÄ purse : NAMES ‚§ï ConPurse ‚¶Å PayDetailsToDomPurse = { pd : PayDetails | pd . to ‚àà dom purse } ‚îî ~\end{LNewADef}
Next, we add those payments filtered accordingly.
\begin{LNewADef}[$epr$ set of payment details via $from$]
‚ï∑ PayDetailsFromDomEPRPurse : ‚Ñô PayDetails |
 ‚àÄ purse : NAMES ‚§ï ConPurse ‚¶Å PayDetailsFromDomEPRPurse = { pd : { pd1 : PayDetails | pd1 . from ‚àà dom purse } | ( purse pd . from ) . status = epr ‚àß ( purse pd . from ) . pdAuth = pd } ‚îî ~\end{LNewADef}
\begin{LNewADef}[$epa$ set of payment details via $from$]
‚ï∑ PayDetailsFromDomEPAPurse : ‚Ñô PayDetails |
 ‚àÄ purse : NAMES ‚§ï ConPurse ‚¶Å PayDetailsFromDomEPAPurse = { pd : { pd1 : PayDetails | pd1 . from ‚àà dom purse } | ( purse pd . from ) . status = epa ‚àß ( purse pd . from ) . pdAuth = pd } ‚îî ~\end{LNewADef}
\begin{LNewADef}[$epv$ set of payment details via $to$]
‚ï∑ PayDetailsToDomEPVPurse : ‚Ñô PayDetails |
 ‚àÄ purse : NAMES ‚§ï ConPurse ‚¶Å PayDetailsToDomEPVPurse = { pd : { pd1 : PayDetails | pd1 . to ‚àà dom purse } | ( purse pd . to ) . status = epv ‚àß ( purse pd . to ) . pdAuth = pd } ‚îî ~\end{LNewADef}
\begin{LNewADef}[$eaTo$ set of payment details via $to$]
‚ï∑ PayDetailsToDomEATOPurse : ‚Ñô PayDetails |
 ‚àÄ purse : NAMES ‚§ï ConPurse ‚¶Å PayDetailsToDomEATOPurse = { pd : { pd1 : PayDetails | pd1 . to ‚àà dom purse } | ( purse pd . to ) . status = eaTo ‚àß ( purse pd . to ) . pdAuth = pd } ‚îî ~\end{LNewADef}
After that, we add the necessary lemmas
\begin{LNewLemma}[$PayDetailsFromDomEPRPurse$ is finite]
\begin{zeves-theorem}{rule lPayDetailsFromPurseEPRIsFinite}
    \forall purse: NAMES \finj ConPurse @ PayDetailsFromDomEPRPurse \in \finset~PayDetails
\end{theorem}~\end{LNewLemma}

\begin{LNewLemma}[$epa$ set of payment details is finite via $from$]
\begin{zeves-theorem}{rule lPayDetailsFromPurseEPAIsFinite}
    \forall purse: NAMES \finj ConPurse @ PayDetailsFromDomEPAPurse \in \finset~PayDetails
\end{theorem}~\end{LNewLemma}

\begin{LNewLemma}[$epv$ set of payment details is finite via $to$]
\begin{zeves-theorem}{rule lPayDetailsToPurseEPVIsFinite}
    \forall purse: NAMES \finj ConPurse @ PayDetailsToDomEPVPurse \in \finset~PayDetails
\end{theorem}~\end{LNewLemma}

\begin{LNewLemma}[$eaTo$ set of payment details is finite via $to$]
\begin{zeves-theorem}{rule lPayDetailsToPurseEATOIsFinite}
    \forall purse: NAMES \finj ConPurse @ PayDetailsToDomEATOPurse \in \finset~PayDetails
\end{theorem}~\end{LNewLemma}
And finally, we prove the original Mondex theorem.
\begin{LThm}[$AuxWorld$ do not add constraints to $ConWorld$] \begin{zeves-theorem}{tAuxWorldDoesNotAddConstraints}
   \forall ConWorld @ \exists_1 NewVariables @ AuxWorld
\end{theorem}~\end{LThm}

\section{Constraints on the ether}\label{ch5.betweenworld}

Due to the sheer size and complexity of the generated domain check proof,
we decided to define $BetweenWorld$ by layering its properties via schema
inclusion. This allows not only a smoother but also much faster proof.
Essentially, we are factoring each case of the original proof with schemas.

This is also a good idea because the assumptions immediately available for
each domain check case from the original $BetweenWorld$ are given
in sequence according to the declared schema predicates. Otherwise, if we
had tried to prove the monolithic version, we would need a plethora of auxiliary
lemmas.

This layering also shows the interrelationship between different properties,
and what predicates they depend upon. In the end, we just combine all properties
to form the complete $BetweenWorld$. This layering idea comes from previous
experience with a ZRC proof the a refinement model checking algorithm.

\begin{LNewSDef}[Between world property $B1$]
‚îå BetweenWorldB1 
AuxWorld |
 ‚àÄ pd : PayDetails | req pd ‚àà ether ‚¶Å pd ‚àà authenticTo ‚îî ~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B2$]
‚îå BetweenWorldB2 
AuxWorld |
 BetweenWorldB1 
‚àÄ pd : PayDetails | req pd ‚àà ether ‚¶Å pd . toSeqNo < ( conAuthPurse pd . to ) . nextSeqNo ‚îî ~\end{LNewSDef}

\begin{LNewSDef}[\textbf{Missing between world property for~}$\mathbf{B3}$]
‚îå BetweenWorldNEW1 
AuxWorld |
 ‚àÄ pd : PayDetails | val pd ‚àà ether ‚¶Å pd ‚àà authenticTo ‚îî ~\end{LNewSDef}

\begin{LNewSDef}[\textbf{Missing between world property for~}$\mathbf{B3}$]
‚îå BetweenWorldNEW2 
AuxWorld |
 ‚àÄ pd : PayDetails | val pd ‚àà ether ‚¶Å pd ‚àà authenticFrom ‚îî ~\end{LNewSDef}

For property $B3$, the original purse was missing additional information about the
authenticity of $val$ messages in the $ether$ for $to$ and $from$ purses. This did
not happen for $rel$ messages, as property $B1$ shows.
Moreover, we include the new properties in the predicate part to have a uniform signature
across  $BetweenWorld$ properties. Although not strictly necessary, it helps \zeves\ while
performing reduction or automatically applying forward ($frules$) rules.
\begin{LNewSDef}[Between world property $B3$]
‚îå BetweenWorldB3 
AuxWorld |
 BetweenWorldNEW1 
BetweenWorldNEW2 
‚àÄ pd : PayDetails | val pd ‚àà ether ‚¶Å pd . toSeqNo < ( conAuthPurse pd . to ) . nextSeqNo ‚àß pd . fromSeqNo < ( conAuthPurse pd . from ) . nextSeqNo ‚îî ~\end{LNewSDef}

\begin{LNewSDef}[\textbf{Missing between world property for~}$\mathbf{B4}$]
‚îå BetweenWorldNEW3 
AuxWorld |
 ‚àÄ pd : PayDetails | ack pd ‚àà ether ‚¶Å pd ‚àà authenticTo ‚îî ~\end{LNewSDef}

\begin{LNewSDef}[\textbf{Missing between world property for~}$\mathbf{B4}$]
‚îå BetweenWorldNEW4 
AuxWorld |
 ‚àÄ pd : PayDetails | ack pd ‚àà ether ‚¶Å pd ‚àà authenticFrom ‚îî ~\end{LNewSDef}

Similarly, for property $B4$, we need to include the authenticity of
$ack$ messages in the $ether$ for $to$ and $from$ purses.
\begin{LNewSDef}[Between world property $B4$]
‚îå BetweenWorldB4 
AuxWorld |
 BetweenWorldNEW3 
BetweenWorldNEW4 
‚àÄ pd : PayDetails | ack pd ‚àà ether ‚¶Å pd . toSeqNo < ( conAuthPurse pd . to ) . nextSeqNo ‚àß pd . fromSeqNo < ( conAuthPurse pd . from ) . nextSeqNo ‚îî ~\end{LNewSDef}

For $B5$ nothing else is needed because the $from$ purses in $fromLogged$ are already authentic,
as given by its definition in $AuxWorld$.
\begin{LNewSDef}[Between world property $B5$]
‚îå BetweenWorldB5 
AuxWorld |
 ‚àÄ pd : fromLogged ‚¶Å pd . fromSeqNo < ( conAuthPurse pd . from ) . nextSeqNo ‚îî ~\end{LNewSDef}

Similarly, for $B6$ $B7$ and $B8$, the $to$ purses in $toLogged$ and $from$ purses in $fromLogged$
are already authentic as well.
\begin{LNewSDef}[Between world property $B6$]
‚îå BetweenWorldB6 
AuxWorld |
 ‚àÄ pd : toLogged ‚¶Å pd . toSeqNo < ( conAuthPurse pd . to ) . nextSeqNo ‚îî ~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B7$]
‚îå BetweenWorldB7 
AuxWorld |
 ‚àÄ pd : fromLogged | ( conAuthPurse pd . from ) . status ‚àà { epr , epa } ‚¶Å pd . fromSeqNo < ( conAuthPurse pd . from ) . pdAuth . fromSeqNo ‚îî ~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B8$]
‚îå BetweenWorldB8 
AuxWorld |
 ‚àÄ pd : toLogged | ( conAuthPurse pd . to ) . status ‚àà { epv , eaTo } ‚¶Å pd . toSeqNo < ( conAuthPurse pd . to ) . pdAuth . toSeqNo ‚îî ~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B9$]
‚îå BetweenWorldB9 
AuxWorld |
 ‚àÄ pd : fromInEpr ‚¶Å disjoint ‚ü® { val pd , ack pd } , ether ‚ü© ‚îî ~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B10$]
‚îå BetweenWorldB10 
AuxWorld |
 ‚àÄ pd : PayDetails ‚¶Å ( req pd ‚àà ether ‚àß ack pd ‚àâ ether ) ‚áî ( pd ‚àà toInEpv ‚à™ toLogged ) ‚îî ~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B11$]
‚îå BetweenWorldB11 
AuxWorld |
 ‚àÄ pd : PayDetails | val pd ‚àà ether ‚àß pd ‚àà toInEpv ‚¶Å pd ‚àà fromInEpa ‚à™ fromLogged ‚îî ~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B12$]
‚îå BetweenWorldB12 
AuxWorld |
 ‚àÄ pd : fromInEpa ‚à™ fromLogged ‚¶Å req pd ‚àà ether ‚îî ~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B13$]
‚îå BetweenWorldB13 
AuxWorld |
 toLogged ‚àà ùîΩ PayDetails ‚îî ~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B14$]
‚îå BetweenWorldB14 
AuxWorld |
 ‚àÄ pd : exceptionLogResult ‚àº ‚¶á ether ‚¶à ‚¶Å pd ‚àà allLogs ‚îî ~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B15$]
‚îå BetweenWorldB15 
AuxWorld |
 ‚àÄ pds : ‚Ñô‚Üò1‚Üñ PayDetails ; name : NAMES | exceptionLogClear ( name , image pds ) ‚àà ether ‚¶Å { name } √ó pds ‚äÜ archive ‚îî ~\end{LNewSDef}

\begin{LNewSDef}[Between world property $B16$]
‚îå BetweenWorldB16 
AuxWorld |
 ‚àÄ pd : fromLogged ‚à™ toLogged ‚¶Å req pd ‚àà ether ‚îî ~\end{LNewSDef}

\begin{LSDef}[Complete between world definition]
‚îÄ BetweenWorld == BetweenWorldB1 ‚àß BetweenWorldB2 ‚àß BetweenWorldB3 ‚àß BetweenWorldB4 ‚àß BetweenWorldB5 ‚àß BetweenWorldB6 ‚àß BetweenWorldB7 ‚àß BetweenWorldB8 ‚àß BetweenWorldB9 ‚àß BetweenWorldB10 ‚àß BetweenWorldB11 ‚àß BetweenWorldB12 ‚àß BetweenWorldB13 ‚àß BetweenWorldB14 ‚àß BetweenWorldB15 ‚àß BetweenWorldB16 ‚îî ~\end{LSDef}

\subsection*{Expanded $BetweenWorld$}

Cannot be a rule because of quantifiers in the goal.
\begin{LNewLemma}[Between world simple expansion]
\begin{zeves-theorem}{lBetweenWorldExpansion}
    \forall BetweenWorld @
    \znote{BetweenWorld components}
    AuxWorld \land \\ \t1
    \znote{BetweenWorld invariant}
    (\forall pd : PayDetails | req~pd \in ether @ pd \in authenticTo) \\
    \land
    (\forall pd : PayDetails | req~pd \in ether @ \\
        \t1 pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo) \\
    \land
    (\forall pd : PayDetails | val~pd \in ether @ pd \in authenticTo) \\
    \land
    (\forall pd : PayDetails | val~pd \in ether @ pd \in authenticFrom) \\
    \land
    (\forall pd : PayDetails | val~pd \in ether @ \\
        \t1 pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo \\
        \t1 \land pd.fromSeqNo < (conAuthPurse~ pd.from).nextSeqNo) \\
    \land
    (\forall pd : PayDetails | ack~pd \in ether @ pd \in authenticTo) \\
    \land
    (\forall pd : PayDetails | ack~pd \in ether @ pd \in authenticFrom) \\
    \land
    (\forall pd : PayDetails | ack~pd \in ether @ \\
        \t1 pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo  \\         \t1 \land pd.fromSeqNo < (conAuthPurse~ pd.from).nextSeqNo) \\
    \land     (\forall pd : fromLogged @  \\         \t1 pd.fromSeqNo < (conAuthPurse~pd.from).nextSeqNo) \\
    \land     (\forall pd : toLogged @ pd.toSeqNo < (conAuthPurse~pd.to).nextSeqNo) \\
    \land     (\forall pd : fromLogged | \\         \t1 (conAuthPurse~pd.from).status \in \{epr,epa\} @  \\         \t2 pd.fromSeqNo \\         \t2 < (conAuthPurse~pd.from).pdAuth.fromSeqNo) \\
    \land     (\forall pd : toLogged | (conAuthPurse~pd.to).status \in \{ epv,eaTo \} @ \\         \t1 pd.toSeqNo < (conAuthPurse~pd.to).pdAuth.toSeqNo) \\
    \land     (\forall pd : fromInEpr @ \disjoint \langle \{ val~pd, ack~pd \} , ether \rangle) \\
    \land     (\forall pd : PayDetails @ \\         \t1 (req~pd \in ether \land ack~pd \notin ether~) \\         \t2 \iff (pd \in toInEpv \cup toLogged)) \\
    \land     (\forall pd : PayDetails | val~pd \in ether \land pd \in toInEpv @ \\         \t1 pd \in fromInEpa \cup fromLogged) \\
    \land     (\forall pd : fromInEpa \cup fromLogged @  req~pd \in ether) \\
    \land     (toLogged \in \finset PayDetails) \\
    \land     (\forall pd : exceptionLogResult\inv \limg ether \rimg @ pd \in allLogs) \\
    \land     (\forall pds : \power_1 PayDetails; name : NAMES | \\             \t2 exceptionLogClear(name, image~pds) \in ether @ \\         \t1 \{name\} \cross pds \subseteq archive) \\
    \land     (\forall pd: fromLogged \cup toLogged @ req~pd \in ether)
\end{theorem}~\end{LNewLemma}

Unfortunately, if $AuxWorld$ elements or invariant are needed in proofs, the
next theorem is required. That is because $AuxWorld$ is blown away by \zeves\
when the closed $BetweenWorld$ appears early on the list of assumptions.
\begin{LNewLemma}[Between $AuxWorld$ expansion]
\begin{zeves-theorem}{lBetweenWorldAuxWorldExpansion}
    \znote{AuxWorld components}
    \forall BetweenWorld @ ConWorld \land
            allLogs \in NAMES \rel PayDetails \land \\ \t1
            authenticFrom \in \power~PayDetails \land
            authenticTo \in \power~PayDetails \land \\ \t1
            fromLogged \in \power~PayDetails \land
            toLogged \in \power~PayDetails \land \\ \t1
            toInEpv \in \power~PayDetails \land
            toInEapayee \in \power~PayDetails \land \\ \t1
            fromInEpr \in \power~PayDetails \land
            fromInEpa \in \power~PayDetails \land \\ \t1
            definitelyLost \in \power~PayDetails \land
            maybeLost \in \power~PayDetails \land \\
        \znote{AuxWorld invariant} \t1
            toInEpv \in \finset~PayDetails \land \\ \t1
            toInEapayee \in \finset~PayDetails \land
            fromInEpr \in \finset~PayDetails \land \\ \t1
            fromInEpa \in \finset~PayDetails \land
            maybeLost \in \finset~PayDetails \land \\ \t1
            authenticFrom \in \finset PayDetails \land
            authenticTo \in \finset PayDetails \land \\ \t1
            fromLogged = \{~ pd: authenticFrom | pd.from \mapsto pd \in allLogs ~\} \land \\ \t1
            toLogged = \{~ pd: authenticTo | pd.to \mapsto pd \in allLogs ~\} \land \\ \t1
            authenticFrom = \{~ pd: PayDetails | pd.from \in \dom~conAuthPurse~\} \land \\ \t1
            authenticTo = \{~ pd: PayDetails | pd.to \in \dom~conAuthPurse~\} \land \\ \t1
            toInEpv = \{~ pd: authenticTo | (conAuthPurse pd.to).status = epv \\
                    \t4 \land (conAuthPurse pd.to).pdAuth = pd ~\} \land \\ \t1
            toInEapayee = \{~ pd: authenticTo | (conAuthPurse pd.to).status = eaTo \\
                    \t5 \land (conAuthPurse pd.to).pdAuth = pd ~\} \land \\ \t1
            fromInEpr = \{~ pd: authenticFrom | (conAuthPurse pd.from).status = epr \\
                    \t5 \land (conAuthPurse pd.from).pdAuth = pd ~\} \land \\ \t1
            fromInEpa = \{~ pd: authenticFrom | (conAuthPurse pd.from).status = epa \\
                    \t5 \land (conAuthPurse pd.from).pdAuth = pd ~\} \land \\ \t1
            allLogs = archive \cup \\
                \t2 \{~ n: \dom~conAuthPurse; pd: PayDetails | pd \in (conAuthPurse~n).exLog ~\} \land \\ \t1
            definitelyLost = toLogged \cap (fromLogged \cup fromInEpa) \land \\ \t1
            maybeLost = (fromInEpa \cup fromLogged) \cap toInEpv \land \\
    \znote{BetweenWorld invariant}\t1
            (\forall pd : PayDetails | req~pd \in ether @ pd \in authenticTo)
            \land \\ \t1
            (\forall pd : PayDetails | req~pd \in ether @
                 pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo) \\ \t1
            \land
            (\forall pd : PayDetails | val~pd \in ether @ pd \in authenticTo) \land \\ \t1
            (\forall pd : PayDetails | val~pd \in ether @ pd \in authenticFrom) \land \\ \t1
            (\forall pd : PayDetails | val~pd \in ether @ pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo \\
                \t2 \land pd.fromSeqNo < (conAuthPurse~ pd.from).nextSeqNo) \land \\ \t1
            (\forall pd : PayDetails | ack~pd \in ether @ pd \in authenticTo)\land  \\ \t1
            (\forall pd : PayDetails | ack~pd \in ether @ pd \in authenticFrom) \land \\ \t1
            (\forall pd : PayDetails | ack~pd \in ether @ pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo  \\                 \t2 \land pd.fromSeqNo < (conAuthPurse~ pd.from).nextSeqNo) \land \\ \t1
            (\forall pd : fromLogged @  pd.fromSeqNo < (conAuthPurse~pd.from).nextSeqNo) \land \\ \t1
            (\forall pd : toLogged @ pd.toSeqNo < (conAuthPurse~pd.to).nextSeqNo) \land  \\ \t1
            (\forall pd : fromLogged | (conAuthPurse~pd.from).status \in \{epr,epa\} @  \\                 \t2 pd.fromSeqNo < (conAuthPurse~pd.from).pdAuth.fromSeqNo) \land \\ \t1
            (\forall pd : toLogged | (conAuthPurse~pd.to).status \in \{ epv,eaTo \} @ \\                 \t2 pd.toSeqNo < (conAuthPurse~pd.to).pdAuth.toSeqNo) \land \\ \t1
            (\forall pd : fromInEpr @ \disjoint \langle \{ val~pd, ack~pd \} , ether \rangle) \land \\ \t1
            (\forall pd : PayDetails @ (req~pd \in ether \land ack~pd \notin ether~)
                \iff (pd \in toInEpv \cup toLogged)) \\ \t1
            \land (\forall pd : PayDetails | val~pd \in ether \land pd \in toInEpv @ \\                 \t3 pd \in fromInEpa \cup fromLogged) \land \\ \t1
            (\forall pd : fromInEpa \cup fromLogged @  req~pd \in ether) \land
            (toLogged \in \finset PayDetails) \land \\ \t1
            (\forall pd : exceptionLogResult\inv \limg ether \rimg @ pd \in allLogs) \land \\ \t1
            (\forall pds : \power_1 PayDetails; name : NAMES | \\                     \t3 exceptionLogClear(name, image~pds) \in ether @ \\                 \t4 \{name\} \cross pds \subseteq archive) \land \\ \t1
            (\forall pd: fromLogged \cup toLogged @ req~pd \in ether)
\end{theorem}~\end{LNewLemma}
These theorems would be equivalent to having individual forward rules (frule),
one for each invariant property and schema component. (see Chapter~\ref{ch10} for
were it is used).
\begin{LNewLemma}[Between world full expansion]
\begin{zeves-theorem}{lBetweenWorldFullExpansion}
    \znote{ConWorld components and invariant}
    \forall BetweenWorld @ conAuthPurse \in NAMES \finj ConPurse \land
            ether \in \power~MESSAGE \land \\ \t1
            archive \in Logbook \land  (\forall n: \dom~conAuthPurse @ (conAuthPurse~n).name = n) \land \\ \t1
            (\forall nld: archive @ first~nld \in \dom~conAuthPurse) \land \\
        \znote{AuxWorld components and invariant} \t1
            allLogs \in NAMES \rel PayDetails \land
            authenticFrom \in \power~PayDetails \land \\ \t1
            authenticTo \in \power~PayDetails \land
            fromLogged \in \power~PayDetails \land \\ \t1
            toLogged \in \power~PayDetails \land
            toInEpv \in \power~PayDetails \land \\ \t1
            toInEapayee \in \power~PayDetails \land
            fromInEpr \in \power~PayDetails \land \\ \t1
            fromInEpa \in \power~PayDetails \land
            definitelyLost \in \power~PayDetails \land \\ \t1
            maybeLost \in \power~PayDetails \land
            toInEpv \in \finset~PayDetails \land \\ \t1
            toInEapayee \in \finset~PayDetails \land
            fromInEpr \in \finset~PayDetails \land \\ \t1
            fromInEpa \in \finset~PayDetails \land
            maybeLost \in \finset~PayDetails \land \\ \t1
            authenticFrom \in \finset PayDetails \land
            authenticTo \in \finset PayDetails \land \\ \t1
            fromLogged = \{~ pd: authenticFrom | pd.from \mapsto pd \in allLogs ~\} \land \\ \t1
            toLogged = \{~ pd: authenticTo | pd.to \mapsto pd \in allLogs ~\} \land \\ \t1
            authenticFrom = \{~ pd: PayDetails | pd.from \in \dom~conAuthPurse~\} \land \\ \t1
            authenticTo = \{~ pd: PayDetails | pd.to \in \dom~conAuthPurse~\} \land \\ \t1
            toInEpv = \{~ pd: authenticTo | (conAuthPurse pd.to).status = epv \\
                    \t4 \land (conAuthPurse pd.to).pdAuth = pd ~\} \land \\ \t1
            toInEapayee = \{~ pd: authenticTo | (conAuthPurse pd.to).status = eaTo \\
                    \t5 \land (conAuthPurse pd.to).pdAuth = pd ~\} \land \\ \t1
            fromInEpr = \{~ pd: authenticFrom | (conAuthPurse pd.from).status = epr \\
                    \t5 \land (conAuthPurse pd.from).pdAuth = pd ~\} \land \\ \t1
            fromInEpa = \{~ pd: authenticFrom | (conAuthPurse pd.from).status = epa \\
                    \t5 \land (conAuthPurse pd.from).pdAuth = pd ~\} \land \\ \t1
            allLogs = archive \cup \\
                \t2 \{~ n: \dom~conAuthPurse; pd: PayDetails | pd \in (conAuthPurse~n).exLog ~\} \land \\ \t1
            definitelyLost = toLogged \cap (fromLogged \cup fromInEpa) \land \\ \t1
            maybeLost = (fromInEpa \cup fromLogged) \cap toInEpv \land \\
    \znote{BetweenWorld invariant}\t1
            (\forall pd : PayDetails | req~pd \in ether @ pd \in authenticTo)
            \land \\ \t1
            (\forall pd : PayDetails | req~pd \in ether @
                 pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo) \\ \t1
            \land
            (\forall pd : PayDetails | val~pd \in ether @ pd \in authenticTo) \land \\ \t1
            (\forall pd : PayDetails | val~pd \in ether @ pd \in authenticFrom) \land \\ \t1
            (\forall pd : PayDetails | val~pd \in ether @ pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo \\
                \t2 \land pd.fromSeqNo < (conAuthPurse~ pd.from).nextSeqNo) \land \\ \t1
            (\forall pd : PayDetails | ack~pd \in ether @ pd \in authenticTo)\land  \\ \t1
            (\forall pd : PayDetails | ack~pd \in ether @ pd \in authenticFrom) \land \\ \t1
            (\forall pd : PayDetails | ack~pd \in ether @ pd.toSeqNo < (conAuthPurse~ pd.to).nextSeqNo  \\                 \t2 \land pd.fromSeqNo < (conAuthPurse~ pd.from).nextSeqNo) \land \\ \t1
            (\forall pd : fromLogged @  pd.fromSeqNo < (conAuthPurse~pd.from).nextSeqNo) \land \\ \t1
            (\forall pd : toLogged @ pd.toSeqNo < (conAuthPurse~pd.to).nextSeqNo) \land  \\ \t1
            (\forall pd : fromLogged | (conAuthPurse~pd.from).status \in \{epr,epa\} @  \\                 \t2 pd.fromSeqNo < (conAuthPurse~pd.from).pdAuth.fromSeqNo) \land \\ \t1
            (\forall pd : toLogged | (conAuthPurse~pd.to).status \in \{ epv,eaTo \} @ \\                 \t2 pd.toSeqNo < (conAuthPurse~pd.to).pdAuth.toSeqNo) \land \\ \t1
            (\forall pd : fromInEpr @ \disjoint \langle \{ val~pd, ack~pd \} , ether \rangle) \land \\ \t1
            (\forall pd : PayDetails @ (req~pd \in ether \land ack~pd \notin ether~)
                \iff (pd \in toInEpv \cup toLogged)) \\ \t1
            \land (\forall pd : PayDetails | val~pd \in ether \land pd \in toInEpv @ \\                 \t3 pd \in fromInEpa \cup fromLogged) \land \\ \t1
            (\forall pd : fromInEpa \cup fromLogged @  req~pd \in ether) \land
            (toLogged \in \finset PayDetails) \land \\ \t1
            (\forall pd : exceptionLogResult\inv \limg ether \rimg @ pd \in allLogs) \land \\ \t1
            (\forall pds : \power_1 PayDetails; name : NAMES | \\                     \t3 exceptionLogClear(name, image~pds) \in ether @ \\                 \t4 \{name\} \cross pds \subseteq archive) \land \\ \t1
            (\forall pd: fromLogged \cup toLogged @ req~pd \in ether)
\end{theorem}~\end{LNewLemma}


\section{Framing schema}\label{ch5.phibop}

We could have used $\Phi BOp$, but this creates a naming compatibility
between the \zeves\ GUI and \zeves\ x-emacs interfaces.
\begin{LSDef}[Between world promotion schema]
‚îå PhiBOp 
ŒîBetweenWorld 
ŒîConPurse 
m? , m! : MESSAGE 
name? : NAMES |
 m? ‚àà ether 
name? ‚àà dom conAuthPurse 
Œ∏ ConPurse = conAuthPurse name? 
conAuthPurse‚Ä≤ = conAuthPurse ‚äï { name? ‚Ü¶ Œ∏ ConPurse ‚Ä≤ } 
archive‚Ä≤ = archive 
ether‚Ä≤ = ether ‚à™ { m! } ‚îî ~\end{LSDef}

\section{$Ignore$, $Increase$ and $Abort$}\label{ch5.ignore.increase.abort}

\begin{LSDef}[Between world ignore operation]
‚îÄ Ignore == [ ŒûBetweenWorld ; name? : NAMES ; m? , m! : MESSAGE | m! = bot ] ‚îî ~\end{LSDef}

\begin{LSDef}[Between world increase operation]
‚îÄ Increase == Ignore ‚à® ( ‚àÉ ŒîConPurse ‚¶Å PhiBOp ‚àß IncreasePurseOkay ) ‚îî ~\end{LSDef}

\begin{LSDef}[Between world abort operation]
‚îÄ Abort == Ignore ‚à® ( ‚àÉ ŒîConPurse ‚¶Å AbortPurseOkay ‚àß [ PhiBOp | m! = bot ] ) ‚îî ~\end{LSDef}

\section{Promoted operations}\label{ch5.promoted}

\subsection{Value transfer operations}\label{ch5.promoted.valuetransfer}

\begin{LSDef}[Between world value transfer $startFrom$ complete operation]
‚îÄ StartFrom == Ignore ‚à® Abort ‚à® ( ‚àÉ ŒîConPurse ‚¶Å PhiBOp ‚àß StartFromPurseOkay ) ‚îî ~\end{LSDef}

\begin{LSDef}[Between world value transfer $startTo$ complete operation]
‚îÄ StartTo == Ignore ‚à® Abort ‚à® ( ‚àÉ ŒîConPurse ‚¶Å PhiBOp ‚àß StartToPurseOkay ) ‚îî ~\end{LSDef}

The next two operations are used in lemmas from Section~\ref{ch14.between-special}.
\begin{LSDef}[Promoted $StartFrom$ without $Ignore$ and $Abort$]
‚îÄ StartFromEafromOkay == ‚àÉ ŒîConPurse ‚¶Å PhiBOp ‚àß StartFromPurseEafromOkay ‚îî ~\end{LSDef}

\begin{LSDef}[Promoted $StartTo$ without $Ignore$ and $Abort$]
‚îÄ StartToEafromOkay == ‚àÉ ŒîConPurse ‚¶Å PhiBOp ‚àß StartToPurseEafromOkay ‚îî ~\end{LSDef}

\begin{LSDef}[Between world value transfer request operation]
‚îÄ Req == Ignore ‚à® ( ‚àÉ ŒîConPurse ‚¶Å PhiBOp ‚àß ReqPurseOkay ) ‚îî ~\end{LSDef}

\begin{LSDef}[Between world value transfer value operation]
‚îÄ Val == Ignore ‚à® ( ‚àÉ ŒîConPurse ‚¶Å PhiBOp ‚àß ValPurseOkay ) ‚îî ~\end{LSDef}

\begin{LSDef}[Between world value transfer acknowledgement operation]
‚îÄ Ack == Ignore ‚à® ( ‚àÉ ŒîConPurse ‚¶Å PhiBOp ‚àß AckPurseOkay ) ‚îî ~\end{LSDef}

\subsection{Exception log operations}\label{ch5.promoted.exception}

\begin{LSDef}[Between world read exception log complete operation]
‚îÄ ReadExceptionLog == Ignore ‚à® ( ‚àÉ ŒîConPurse ‚¶Å PhiBOp ‚àß ReadExceptionLogPurseOkay ) ‚îî ~\end{LSDef}

Why considers abort twice?
\begin{LSDef}[Between world clear exception log complete operation]
‚îÄ ClearExceptionLog == Ignore ‚à® Abort ‚à® ( ‚àÉ ŒîConPurse ‚¶Å PhiBOp ‚àß ClearExceptionLogPurseOkay ) ‚îî ~\end{LSDef}

The next two operations are used in lemmas from Section~\ref{ch14.between-special}.
\begin{LSDef}[Promoted $ReadExceptionLog$ without $Ignore$ and $Abort$]
‚îÄ ReadExceptionLogEafromOkay == ‚àÉ ŒîConPurse ‚¶Å PhiBOp ‚àß ReadExceptionLogPurseEafromOkay ‚îî ~\end{LSDef}

\begin{LSDef}[Promoted $ClearExceptionLog$ without $Ignore$ and $Abort$]
‚îÄ ClearExceptionLogEafromOkay == ‚àÉ ŒîConPurse ‚¶Å PhiBOp ‚àß ClearExceptionLogPurseEafromOkay ‚îî ~\end{LSDef}

\section{Operations at the world level only}\label{ch5.worldop}

\subsection{Exception Log clear authorisation}

\begin{LSDef}[Between world authorised exception log clear operation]
‚îå AuthoriseExLogClearOkay 
ŒîBetweenWorld 
m? , m! : MESSAGE 
name? : NAMES |
 conAuthPurse‚Ä≤ = conAuthPurse 
‚àÉ pds : ‚Ñô‚Üò1‚Üñ PayDetails ‚¶Å { name? } √ó pds ‚äÜ archive ‚àß m! = exceptionLogClear ( name? , image pds ) 
ether‚Ä≤ = ether ‚à™ { m! } 
archive = archive‚Ä≤ ‚îî ~\end{LSDef}

\begin{LSDef}[Authorised between world log clear operation]
‚îÄ AuthoriseExLogClear == Ignore ‚à® AuthoriseExLogClearOkay ‚îî ~\end{LSDef}

\begin{LSDef}[Between world exception log archiving operation]
‚îå Archive 
ŒîBetweenWorld 
m? , m! : MESSAGE 
name? : NAMES |
 conAuthPurse‚Ä≤ = conAuthPurse 
ether‚Ä≤ = ether 
archive ‚äÜ archive‚Ä≤ ‚äÜ archive ‚à™ { log : NAMES √ó PayDetails | exceptionLogResult log ‚àà ether } 
m! = bot ‚îî ~\end{LSDef}

\section{The complete protocol}

\begin{LSDef}[Complete transfer protocol between concrete levels]
‚îÄ CompleteProtocol == StartFrom ‚®ü StartTo ‚®ü Req ‚®ü Val ‚®ü Ack ‚îî ~\end{LSDef}

\newpage
\section{Summary}\label{ch5.summary}

\ldefsummary \lthmsummary \lthmaddeddefsummary \lthmaddedthmsummary \lzevessummary
