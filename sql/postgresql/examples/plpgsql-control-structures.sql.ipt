root
 stmtblock
  stmtmulti
   stmt
    createfunctionstmt
     CREATE
     opt_or_replace
      OR
      REPLACE
     FUNCTION
     func_name
      type_function_name
       identifier
        getAllFoo
        opt_uescape
     func_args_with_defaults
      (
      )
     RETURNS
     func_return
      func_type
       typename
        SETOF
        simpletypename
         generictype
          type_function_name
           identifier
            foo
            opt_uescape
          opt_type_modifiers
        opt_array_bounds
     createfunc_opt_list
      createfunc_opt_item
       AS
       func_as
        sconst
         anysconst
          $BODY$
          \nDECLARE\n    r foo%rowtype;\nBEGIN\n    FOR r IN SELECT * FROM foo\n    WHERE fooid > 0\n    LOOP\n        -- can do some processing here\n        RETURN NEXT r; -- return current row of SELECT\n    END LOOP;\n    RETURN;\nIF parentid IS NULL OR parentid = ''\nTHEN\n    RETURN fullname;\nELSE\n    RETURN hp_true_filename(parentid) || '/' || fullname;\nEND IF;\n\nIF v_count > 0 THEN\n    INSERT INTO users_count (count) VALUES (v_count);\n    RETURN 't';\nELSE\n    RETURN 'f';\nEND IF;\nIF number = 0 THEN\n    result := 'zero';\nELSIF number > 0 THEN\n    result := 'positive';\nELSIF number < 0 THEN\n    result := 'negative';\nELSE\n    -- hmm, the only other possibility is that number is null\n    result := 'NULL';\nEND IF;\nIF demo_row.sex = 'm' THEN\n    pretty_sex := 'man';\nELSE\n    IF demo_row.sex = 'f' THEN\n        pretty_sex := 'woman';\n    END IF;\nEND IF;\n\nCASE x\n    WHEN 1, 2 THEN\n        msg := 'one or two';\n    ELSE\n        msg := 'other value than one or two';\nEND CASE;\n\nCASE\n    WHEN x BETWEEN 0 AND 10 THEN\n        msg := 'value is between zero and ten';\n    WHEN x BETWEEN 11 AND 20 THEN\n        msg := 'value is between eleven and twenty';\nEND CASE;\n\nLOOP\n    -- some computations\n    IF count > 0 THEN\n        EXIT;  -- exit loop\n    END IF;\nEND LOOP;\n\nLOOP\n    -- some computations\n    EXIT WHEN count > 0;  -- same result as previous example\nEND LOOP;\n\n<<ablock>>\nBEGIN\n    -- some computations\n    IF stocks > 100000 THEN\n        EXIT ablock;  -- causes exit from the BEGIN block\n    END IF;\n    -- computations here will be skipped when stocks > 100000\nEND;\n\n\nLOOP\n    -- some computations\n    EXIT WHEN count > 100;\n    CONTINUE WHEN count < 50;\n    -- some computations for count IN [50 .. 100]\nEND LOOP;\n\nWHILE amount_owed > 0 AND gift_certificate_balance > 0 LOOP\n    EXIT WHEN count > 100;\n    -- some computations here\nEND LOOP;\n\nWHILE NOT done LOOP\n    EXIT WHEN count > 100;\n    -- some computations here\nEND LOOP;\n\nFOR i IN 1..10 LOOP\n    -- i will take on the values 1,2,3,4,5,6,7,8,9,10 within the loop\nEND LOOP;\n\nFOR i IN REVERSE 10..1 LOOP\n    -- i will take on the values 10,9,8,7,6,5,4,3,2,1 within the loop\nEND LOOP;\n\nFOR i IN REVERSE 10..1 BY 2 LOOP\n    -- i will take on the values 10,8,6,4,2 within the loop\nEND LOOP;\n\nEND\n
          $BODY$
         opt_uescape
      createfunc_opt_item
       LANGUAGE
       nonreservedword_or_sconst
        nonreservedword
         identifier
          plpgsql
          opt_uescape
   ;
   stmt
    createfunctionstmt
     CREATE
     opt_or_replace
     FUNCTION
     func_name
      type_function_name
       identifier
        cs_refresh_mviews
        opt_uescape
     func_args_with_defaults
      (
      )
     RETURNS
     func_return
      func_type
       typename
        simpletypename
         numeric
          integer
        opt_array_bounds
     createfunc_opt_list
      createfunc_opt_item
       AS
       func_as
        sconst
         anysconst
          $$
          \nDECLARE\n    mviews RECORD;\nBEGIN\n    RAISE NOTICE 'Refreshing materialized views...';\n\n    FOR mviews IN SELECT * FROM cs_materialized_views ORDER BY sort_key LOOP\n\n        -- Now "mviews" has one record from cs_materialized_views\n\n        RAISE NOTICE 'Refreshing materialized view %s ...', quote_ident(mviews.mv_name);\n        EXECUTE 'TRUNCATE TABLE ' || quote_ident(mviews.mv_name);\n        EXECUTE 'INSERT INTO '\n                   || quote_ident(mviews.mv_name) || ' '\n                   || mviews.mv_query;\n    END LOOP;\n\n    RAISE NOTICE 'Done refreshing materialized views.';\n    RETURN 1;\nEND;\n
          $$
         opt_uescape
      createfunc_opt_item
       LANGUAGE
       nonreservedword_or_sconst
        nonreservedword
         identifier
          plpgsql
          opt_uescape
   ;
   stmt
    createfunctionstmt
     CREATE
     opt_or_replace
     FUNCTION
     func_name
      type_function_name
       identifier
        sum
        opt_uescape
     func_args_with_defaults
      (
      func_args_with_defaults_list
       func_arg_with_default
        func_arg
         func_type
          typename
           simpletypename
            numeric
             int
           opt_array_bounds
            [
            ]
      )
     RETURNS
     func_return
      func_type
       typename
        simpletypename
         generictype
          type_function_name
           identifier
            int8
            opt_uescape
          opt_type_modifiers
        opt_array_bounds
     createfunc_opt_list
      createfunc_opt_item
       AS
       func_as
        sconst
         anysconst
          $$
          \nDECLARE\n  s int8 := 0;\n  x int;\nBEGIN\n  FOREACH x IN ARRAY 
          $1\n  LOOP\n    s := s + x;\n  END LOOP;\n  RETURN s;\nEND;\n
          $$
         opt_uescape
      createfunc_opt_item
       LANGUAGE
       nonreservedword_or_sconst
        nonreservedword
         identifier
          plpgsql
          opt_uescape
   ;
   stmt
    createfunctionstmt
     CREATE
     opt_or_replace
     FUNCTION
     func_name
      type_function_name
       identifier
        scan_rows
        opt_uescape
     func_args_with_defaults
      (
      func_args_with_defaults_list
       func_arg_with_default
        func_arg
         func_type
          typename
           simpletypename
            numeric
             int
           opt_array_bounds
            [
            ]
      )
     RETURNS
     func_return
      func_type
       typename
        simpletypename
         generictype
          type_function_name
           identifier
            void
            opt_uescape
          opt_type_modifiers
        opt_array_bounds
     createfunc_opt_list
      createfunc_opt_item
       AS
       func_as
        sconst
         anysconst
          $$
          \nDECLARE\n  x int[];\nBEGIN\n  FOREACH x SLICE 1 IN ARRAY 
          $1\n  LOOP\n    RAISE NOTICE 'row = %', x;\n  END LOOP;\n\nBEGIN\n    UPDATE mytab SET firstname = 'Joe' WHERE lastname = 'Jones';\n    x := x + 1;\n    y := x / 0;\nEXCEPTION\n    WHEN division_by_zero THEN\n        RAISE NOTICE 'caught division_by_zero';\n        RETURN x;\nEND;\n\nEND;\n
          $$
         opt_uescape
      createfunc_opt_item
       LANGUAGE
       nonreservedword_or_sconst
        nonreservedword
         identifier
          plpgsql
          opt_uescape
   ;
   stmt
    createfunctionstmt
     CREATE
     opt_or_replace
     FUNCTION
     func_name
      type_function_name
       identifier
        merge_db
        opt_uescape
     func_args_with_defaults
      (
      func_args_with_defaults_list
       func_arg_with_default
        func_arg
         param_name
          type_function_name
           unreserved_keyword
            key
         func_type
          typename
           simpletypename
            numeric
             INT
           opt_array_bounds
       ,
       func_arg_with_default
        func_arg
         param_name
          type_function_name
           unreserved_keyword
            data
         func_type
          typename
           simpletypename
            generictype
             type_function_name
              unreserved_keyword
               TEXT
             opt_type_modifiers
           opt_array_bounds
      )
     RETURNS
     func_return
      func_type
       typename
        simpletypename
         generictype
          type_function_name
           identifier
            VOID
            opt_uescape
          opt_type_modifiers
        opt_array_bounds
     createfunc_opt_list
      createfunc_opt_item
       AS
       func_as
        sconst
         anysconst
          $$
          \nBEGIN\n    LOOP\n        -- first try to update the key\n        UPDATE db SET b = data WHERE a = key;\n        IF found THEN\n            RETURN;\n        END IF;\n        -- not there, so try to insert the key\n        -- if someone else inserts the same key concurrently,\n        -- we could get a unique-key failure\n        BEGIN\n            INSERT INTO db(a,b) VALUES (key, data);\n            RETURN;\n        EXCEPTION WHEN unique_violation THEN\n            -- Do nothing, and loop to try the UPDATE again.\n        END;\n    END LOOP;\nBEGIN\n  -- some processing which might cause an exception\n\tNULL;\nEXCEPTION WHEN OTHERS THEN\n  GET STACKED DIAGNOSTICS text_var1 = MESSAGE_TEXT,\n                          text_var2 = PG_EXCEPTION_DETAIL,\n                          text_var3 = PG_EXCEPTION_HINT;\nEND;\nEND;\n
          $$
         opt_uescape
      createfunc_opt_item
       LANGUAGE
       nonreservedword_or_sconst
        nonreservedword
         identifier
          plpgsql
          opt_uescape
   ;
 <EOF>
