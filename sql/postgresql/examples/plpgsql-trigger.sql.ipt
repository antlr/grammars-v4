root
 stmtblock
  stmtmulti
   stmt
    createfunctionstmt
     CREATE
     opt_or_replace
     FUNCTION
     func_name
      type_function_name
       identifier
        emp_stamp
        opt_uescape
     func_args_with_defaults
      (
      )
     RETURNS
     func_return
      func_type
       typename
        simpletypename
         generictype
          type_function_name
           unreserved_keyword
            trigger
          opt_type_modifiers
        opt_array_bounds
     createfunc_opt_list
      createfunc_opt_item
       AS
       func_as
        sconst
         anysconst
          $emp_stamp$
          \n    BEGIN\n        -- Check that empname and salary are given\n        IF NEW.empname IS NULL THEN\n            RAISE EXCEPTION 'empname cannot be null';\n        END IF;\n        IF NEW.salary IS NULL THEN\n            RAISE EXCEPTION '% cannot have null salary', NEW.empname;\n        END IF;\n\n        -- Who works for us when she must pay for it?\n        IF NEW.salary < 0 THEN\n            RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;\n        END IF;\n\n        -- Remember who changed the payroll when\n        NEW.last_date := current_timestamp;\n        NEW.last_user := current_user;\n        RETURN NEW;\n    END;\n
          $emp_stamp$
         opt_uescape
      createfunc_opt_item
       LANGUAGE
       nonreservedword_or_sconst
        nonreservedword
         identifier
          plpgsql
          opt_uescape
   ;
   stmt
    createfunctionstmt
     CREATE
     opt_or_replace
      OR
      REPLACE
     FUNCTION
     func_name
      type_function_name
       identifier
        process_emp_audit
        opt_uescape
     func_args_with_defaults
      (
      )
     RETURNS
     func_return
      func_type
       typename
        simpletypename
         generictype
          type_function_name
           unreserved_keyword
            TRIGGER
          opt_type_modifiers
        opt_array_bounds
     createfunc_opt_list
      createfunc_opt_item
       AS
       func_as
        sconst
         anysconst
          $emp_audit$
          \n    BEGIN\n        --\n        -- Create a row in emp_audit to reflect the operation performed on emp,\n        -- make use of the special variable TG_OP to work out the operation.\n        --\n        IF (TG_OP = 'DELETE') THEN\n            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;\n            RETURN OLD;\n        ELSIF (TG_OP = 'UPDATE') THEN\n            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;\n            RETURN NEW;\n        ELSIF (TG_OP = 'INSERT') THEN\n            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;\n            RETURN NEW;\n        END IF;\n        RETURN NULL; -- result is ignored since this is an AFTER trigger\n    END;\n
          $emp_audit$
         opt_uescape
      createfunc_opt_item
       LANGUAGE
       nonreservedword_or_sconst
        nonreservedword
         identifier
          plpgsql
          opt_uescape
   ;
   stmt
    createtrigstmt
     CREATE
     TRIGGER
     name
      colid
       identifier
        emp_audit
        opt_uescape
     triggeractiontime
      AFTER
     triggerevents
      triggeroneevent
       INSERT
      OR
      triggeroneevent
       UPDATE
      OR
      triggeroneevent
       DELETE
     ON
     qualified_name
      colid
       identifier
        emp
        opt_uescape
     triggerreferencing
     triggerforspec
      FOR
      triggerforopteach
       EACH
      triggerfortype
       ROW
     triggerwhen
     EXECUTE
     function_or_procedure
      PROCEDURE
     func_name
      type_function_name
       identifier
        process_emp_audit
        opt_uescape
     (
     triggerfuncargs
     )
   ;
   stmt
    createfunctionstmt
     CREATE
     opt_or_replace
      OR
      REPLACE
     FUNCTION
     func_name
      type_function_name
       identifier
        update_emp_view
        opt_uescape
     func_args_with_defaults
      (
      )
     RETURNS
     func_return
      func_type
       typename
        simpletypename
         generictype
          type_function_name
           unreserved_keyword
            TRIGGER
          opt_type_modifiers
        opt_array_bounds
     createfunc_opt_list
      createfunc_opt_item
       AS
       func_as
        sconst
         anysconst
          $$
          \n    BEGIN\n        --\n        -- Perform the required operation on emp, and create a row in emp_audit\n        -- to reflect the change made to emp.\n        --\n        IF (TG_OP = 'DELETE') THEN\n            DELETE FROM emp WHERE empname = OLD.empname;\n            IF NOT FOUND THEN RETURN NULL; END IF;\n\n            OLD.last_updated = now();\n            INSERT INTO emp_audit VALUES('D', user, OLD.*);\n            RETURN OLD;\n        ELSIF (TG_OP = 'UPDATE') THEN\n            UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;\n            IF NOT FOUND THEN RETURN NULL; END IF;\n\n            NEW.last_updated = now();\n            INSERT INTO emp_audit VALUES('U', user, NEW.*);\n            RETURN NEW;\n        ELSIF (TG_OP = 'INSERT') THEN\n            INSERT INTO emp VALUES(NEW.empname, NEW.salary);\n\n            NEW.last_updated = now();\n            INSERT INTO emp_audit VALUES('I', user, NEW.*);\n            RETURN NEW;\n        END IF;\n    END;\n
          $$
         opt_uescape
      createfunc_opt_item
       LANGUAGE
       nonreservedword_or_sconst
        nonreservedword
         identifier
          plpgsql
          opt_uescape
   ;
   stmt
    createtrigstmt
     CREATE
     TRIGGER
     name
      colid
       identifier
        emp_audit
        opt_uescape
     triggeractiontime
      INSTEAD
      OF
     triggerevents
      triggeroneevent
       INSERT
      OR
      triggeroneevent
       UPDATE
      OR
      triggeroneevent
       DELETE
     ON
     qualified_name
      colid
       identifier
        emp_view
        opt_uescape
     triggerreferencing
     triggerforspec
      FOR
      triggerforopteach
       EACH
      triggerfortype
       ROW
     triggerwhen
     EXECUTE
     function_or_procedure
      PROCEDURE
     func_name
      type_function_name
       identifier
        update_emp_view
        opt_uescape
     (
     triggerfuncargs
     )
   ;
   stmt
    createfunctionstmt
     CREATE
     opt_or_replace
      OR
      REPLACE
     FUNCTION
     func_name
      type_function_name
       identifier
        maint_sales_summary_bytime
        opt_uescape
     func_args_with_defaults
      (
      )
     RETURNS
     func_return
      func_type
       typename
        simpletypename
         generictype
          type_function_name
           unreserved_keyword
            TRIGGER
          opt_type_modifiers
        opt_array_bounds
     createfunc_opt_list
      createfunc_opt_item
       AS
       func_as
        sconst
         anysconst
          $maint_sales_summary_bytime$
          \n    DECLARE\n        delta_time_key          integer;\n        delta_amount_sold       numeric(15,2);\n        delta_units_sold        numeric(12);\n        delta_amount_cost       numeric(15,2);\n    BEGIN\n\n        -- Work out the increment/decrement amount(s).\n        IF (TG_OP = 'DELETE') THEN\n\n            delta_time_key = OLD.time_key;\n            delta_amount_sold = -1 * OLD.amount_sold;\n            delta_units_sold = -1 * OLD.units_sold;\n            delta_amount_cost = -1 * OLD.amount_cost;\n\n        ELSIF (TG_OP = 'UPDATE') THEN\n\n            -- forbid updates that change the time_key -\n            -- (probably not too onerous, as DELETE + INSERT is how most\n            -- changes will be made).\n            IF ( OLD.time_key != NEW.time_key) THEN\n                RAISE EXCEPTION 'Update of time_key : % -> % not allowed',\n                                                      OLD.time_key, NEW.time_key;\n            END IF;\n\n            delta_time_key = OLD.time_key;\n            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;\n            delta_units_sold = NEW.units_sold - OLD.units_sold;\n            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;\n\n        ELSIF (TG_OP = 'INSERT') THEN\n\n            delta_time_key = NEW.time_key;\n            delta_amount_sold = NEW.amount_sold;\n            delta_units_sold = NEW.units_sold;\n            delta_amount_cost = NEW.amount_cost;\n\n        END IF;\n\n\n        -- Insert or update the summary row with the new values.\n        <<insert_update>>\n        LOOP\n            UPDATE sales_summary_bytime\n                SET amount_sold = amount_sold + delta_amount_sold,\n                    units_sold = units_sold + delta_units_sold,\n                    amount_cost = amount_cost + delta_amount_cost\n                WHERE time_key = delta_time_key;\n\n            EXIT insert_update WHEN found;\n\n            BEGIN\n                INSERT INTO sales_summary_bytime (\n                            time_key,\n                            amount_sold,\n                            units_sold,\n                            amount_cost)\n                    VALUES (\n                            delta_time_key,\n                            delta_amount_sold,\n                            delta_units_sold,\n                            delta_amount_cost\n                           );\n\n                EXIT insert_update;\n\n            EXCEPTION\n                WHEN UNIQUE_VIOLATION THEN\n                    -- do nothing\n            END;\n        END LOOP insert_update;\n\n        RETURN NULL;\n\n    END;\n
          $maint_sales_summary_bytime$
         opt_uescape
      createfunc_opt_item
       LANGUAGE
       nonreservedword_or_sconst
        nonreservedword
         identifier
          plpgsql
          opt_uescape
   ;
   stmt
    createtrigstmt
     CREATE
     TRIGGER
     name
      colid
       identifier
        maint_sales_summary_bytime
        opt_uescape
     triggeractiontime
      AFTER
     triggerevents
      triggeroneevent
       INSERT
      OR
      triggeroneevent
       UPDATE
      OR
      triggeroneevent
       DELETE
     ON
     qualified_name
      colid
       identifier
        sales_fact
        opt_uescape
     triggerreferencing
     triggerforspec
      FOR
      triggerforopteach
       EACH
      triggerfortype
       ROW
     triggerwhen
     EXECUTE
     function_or_procedure
      PROCEDURE
     func_name
      type_function_name
       identifier
        maint_sales_summary_bytime
        opt_uescape
     (
     triggerfuncargs
     )
   ;
 <EOF>
